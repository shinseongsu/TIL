# 조인 튜닝

### 연습문제-1

```sql
FROM절에 나열한 주문, 고객, 결제방식 순으로 조인하되, 고객테이블과는 NL 조인, 결제방식과는 해시조인을 유도합니다.

select /*+  ___ */
       o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문번호, t.결제방식명
  from 주문 o, 고객 c, 결제방식 t
 where o.주문일자 >= trunc(sysdate)
   and c.고객번호 = o.고객번호
   and t.결제방식코드 = o.결제방식코드     

```

- 정답 : ordered use_nl(c) use_hash(t)

### 연습문제 2

```sql
SQL server에서 주문테이블 기준으로 고객 테이블과 NL 조인유도하기

select o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문금액
  from 주문 o, 고객 c
 where o.주문일자 >= trunc(sysdate)
   and c.고객번호 = o.고객번호
option ( ___ )   

```

- 정답 : force order, loop join


### 연습문제 - 3

```sql
실행되는 순서는?

사원_PK : 사원번호
사원_X1 : 입사일자
고객_PK : 고객번호
고객_X1 : 관리사원번호

select /*+ ordered use_nl(c) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자
   ,c.고객번호, c.고개명, c.전화번호, c.최종주문금액
  from 사원 e, 고객 c
 where c.관리사원번호 = e.사원번호    ---- (가)
   and e.입사일자 >= '19960101'    ---- (나)
   and e.부서코드 = 'Z123'         ---- (다)
   and c.최종주문금액 >= 20000      ---- (라)
```

- 정답 : 나 -> 다 -> 가 -> 라
- 해설 : 고객테이블 인덱스에 최종주문금액에 인덱스가 있다면,   
`나 -> 다 -> 라 -> 가` 순서로 진행할 수도 있다.


### 연습문제 - 4

```sql
사원_PK : 사원번호
사원_X1 : 입사일자
사원_X2 : 부서코드
고객_PK : 고객번호
고객_X1 : 관리사원번호
고객_X2 : 최종주문금액


select /*+ ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자,
       c.고객번호, c.고객명, c.전화번호, c.최종주문금액
  from 사원 e, 고객 c
 where c.관리사원번호 = e.사원번호       ----- 가
   and e.입사일자 >= '19960101'      ----- 나
   and e.부서코드 = 'z123'           ----- 다
   and c.최종주문금액 >= 20000        ----- 라

```

- 가능한 순서

`나 -> 다 -> 가 -> 라 (사용인덱스 : 사원_X1, 고객_X1)`  
`나 -> 다 -> 라 -> 가 (사용인덱스 : 사원_X1, 고객_X2)`  
`다 -> 나 -> 가 -> 라 (사용인덱스 : 사원_X2, 고객_X1)`  
`다 -> 나 -> 라 -> 가 (사용인덱스 : 사원_X2, 고객_X2)`


## NL 조인 특징 

NL 조인의 첫 번째 특징은 랜덤 액세스 위주의 조인 방식이라는 점이다.  
인덱스 구성이 아무리 완벽해도 대량 데이터 조인할 때 NL조인이 불리한 이유다.  

두 번째 특징은 조인을 한 레코드씩 순차적으로 진행한다는 점이다. 따라서 부분범위 처리가 가능하다면 조인할 대상 레코드가 아무리 많아도 빠른 응답 속도를 낼 수 있다.  
순차적으로 진행하므로 먼저 액세스되는 테이블 처리 범위에 의해 전체 일량이 결정되는 특징도 나타난다.  

마지막으로, 다른 조인 방식과 비교할 때 인덱스 구성전략이 특히 중요하다는 점도 중요한 특징이다.  
조인 컬럼에 대한 인덱스가 있느냐 없느냐, 있다면 컬럼이 어떻게 구성했느냐에 따라 조인 효율이 크게 달라진다.

종합하면 NL조인은 `소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 트랜잭션 처리(OLTP) 시스템에 적합한 조인 방식이다.`


## 아래 SQL은 index 힌트에 인덱스명이나 컬럼명을 지정하지 않았으므르 여러가지 액세스 경로가 가능하다. 보기는 각 액세스 경로에서 사용하게 될 인덱스를 나열한 것인데, 가장 가능성이 작은것을 고르시오.

```sql
[인덱스 구성]
사원_PK : 사원번호
사원_X1 : 입사일자
사원_X2 : 부서코드
고객_PK : 고객번호
고객_X1 : 관리사원번호
고객_X2 : 최종주문금액

[SQL]
SELECT /*+ ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
  FROM 사원 e, 고객 c
 WHERE c.관리사원번호 = e.사원번호
   AND e.입사일자   >= '19960101'
   AND e.부서코드    = 'z123'
   AND e.부서코드    = 20000     
```

- 사원_X1, 고객_X1
- 사원_X1, 고객_X2
- 사원_X2, 고객_X1
- 사원_X1, 고객_X2


## 아래 SQL에 대한 튜닝 방안으로 가장 효과적인 것을 고르시오.

```sql
> 한 달 간 거래 건수는 평균 20만 건

select p.상품코드, p.상품가격, t.거래일자, t.거래수량, t.거래금액
  from 상품 p, 거래 t
 where p.상품분류코드 = 'KTG'
   and p.상품가격 between 100000 and 200000
   and t.상품코드 = p.상품코드
   and t.거래일자 between '20210101' and '20210131'


rows   |   Row Source Operation
---------------------------------
368        NESTED LOOPS
69            TABLE ACCESS BY INDEX ROWID 상품
9185            INDEX RANGE SCAN 상품_X01
368           TABLE ACCESS BY INDEX ROWID 거래
385             INDEX RANGE SCAN 거래_X02

```

한 달간 주먼 건수는 평균 20만 건이므로 조인 순서를 변경해서 거래를 먼저 드라이빙하는 것은 성능 향상에 도움이 되지 않는다.

상품_X01 인덱스 구성이 단일 컬럼이든 다중 컬럼이든, 최선두 컬럼에 대한 단일 조건으로 인덱스를 Rnage Scan 했으므로 인덱스 스캔 비효율이 없다.

결국, 상품 테이블에 대한 랜덤 액세스가 많은 것이 문제다. 테이블 액세스량은 컬럼 순서를 조정해도 줄지 않으므로 테이블에서 필터링된 조건절 컬럼을 `상품_X1 인덱스에 추가해 주는 것만이 해법이다.`


## SQL에 대한 튜닝 방안으로 가장 적절한 것은?

```sql
[ 인덱스 구성 ]
상품_PK : 상품코드
상품_X01 : 상품분류코드 + 상품가격 + 공급업체코드
거래_PK : 거래번호
거래_X01 : 거래일자 + 상품코드
거래_X02 : 상품코드 + 거래구분코드 + 거래일자

select p.상품코드, p.상품가격, t.거래일자, t.거래수량, t.거래금액
  from 상품 p, 거래 t
 where p.상품분류코드 = 'KTG'
   and p.공급업체코드 = 'SP83732'
   and p.상품가격 between 10000 and 100000 
   and t.상품코드 = p.상품코드
   and t.거래일자 between '20210101' and '20210131'


rows         rows source Operation
-------------------------------------
368       NESTED LOOP (cr=1311, pr=124, pw=0, time=1622)
69          TABLE ACCESS BY INDEX ROWID 상품 (cr=986 pr=35 pw=0 time=659)
69            INDEX RANGE SCAN 상품_X01 (cr =922 pr=31 pw=0 time=645)
368         TABLE ACCESS BY INDEX ROWID 거래 (cr=325 pr=89 pw=0 time=963)
385           INDEX RANGE SCAN 거래_X02 (cr=140 pr=21 pw=0 time=326)


```

주어진 조건에 대한 상품_X01 인덱스 스캔 효율이 매우 좋지 않다.  

69 로우를 얻기 위해 인덱스에서 922개 블록을 읽었기 때문이다.   

한 블록에 평균 1,000개 로우가 저장돼 있다면, 922,000개 가량의 로우를 읽은 셈이다. 상품가격을 인덱스 맨 뒤로 옮기면 문제를 해결할 수 있다.



## SQ 트레이스를 수집한 결과 Row Source Operation이 아래와 같다. 튜닝을 위해 우선적으로 검토해야 할것은?

```sql
[인덱스 구성]
상품_PK : 상품코드
상품_X01 : 공급업체코드 + 상품가격
거래_PK : 거래번호
거래_X01 : 거래번호 + 상품코드
거래_X02 : 상품코드 + 거래일자


select p.상품코드, p.상품가격, t.거래일자, t.거래수량, t.거래금액
   from 상품 p, 거래 t
  where p.공급업체코드 = 'SP93732'
    and p.상품가격 between 10000 and 20000
    and t.상품코드 = p.상품코드
    and t.거래일자 between '20210101' and '20210131'


Rows           Row Source Operation
---------------------------------------
368       NESTED LOOPS (cr=25667 pr=3548 pw=0)
69          TABLE ACCESS BY INDEX ROWID 상품 (cr=42 pr=0 pw=0)
69            INDEX RANGE SCAN 상품_X01 (cr=2 pr=0 pw=0)
368         TABLE ACCESS BY INDEX ROWID 거래(cr=25625 pr=3548 pw=0)
368           INDEX RANGE SCAN 거래_X01 (cr=25257 pr=3421 pw=0)
```

거래_X01 인덱스에서 368 로우를 얻는 과정에 25,257개 블록을 읽었다. 인덱스를 69번 수직 탐색한 것에 비해 상당히 많은 인덱스 블록을 읽었으므로 인덱스 스캔 효율이 좋지 않다는 사실을 알 수 있다.

거래_X01 인덱스 선두 컬럼인 거래일자가 BETWEEN 조건이므로 상품코드를 필터링하는 것이 문제이다. 상품코드가 선두인 거래_X02 인덱스로 변경해 주면 상당한 성능 개선 효과를 얻을 수 있다.
