# 1. 데이터베이스 아키텍처

```
오라클에서는 디스크에 저장된 데이터 집합(Datafile, Redo Log File, Control File 등)을 Database라고 부른다.
그리고 SGA 공유 메모리 영역과 이를 액세스하는 프로세스 집합을 합쳐서 Instance라고 부른다.
```
<br>

## 백그라운드 프로세스

**System Monitor (SMON)** : 장애가 발생한 시스템을 재기동할 때 인스턴스 복구를 수행하고, 임시 세그먼트와 익스텐트를 모니터링 한다.  

**Process Monitor** : 이상이 생긴 프로세스가 사용하던 리소스를 복구한다.  

**Database Writers (DBWn)** : 버퍼캐시에 있는 Dirty 버퍼를 데이터파일에 기록한다.  

**Log Writer (LGWR)** : 로그 버퍼 엔트리를 Redo 로그 파일에 기록한다.  

**Archiver (ARCn)**: 꽉 찬 Redo 로그가 덮어 쓰여지기 전에 Archive 로그 디렉토리로 백업한다.  

**Checkpoint(CKPT)** : Checkpoint 프로세스는 이전에 Checkpoint가 일어났던 마지막 시점 이후의 데이터베이스 변경 사항을 데이터파일에 기록하도록 트리거링하고, 기록이 완료되면 현재 어디까지 기록했는지 컨트롤파일과 데이터 파일 헤더에 저장한다.  

**Recoverer(RECO)** : 분산 트랜잭션 과정에 발생한 문제를 해결한다.

<br>

## 데이터 저장 구조

`블록(=페이지)` : 대부분 DBMS는 블록 단위로 I/O 한다. 이는 하나의 레코드에서 하나의 컬럼만 읽더라도 그것이 속한 블록을 통째로 읽게 됨을 뜻한다.  

`익스텐트` : 공간을 확장하는 단위다. 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스(물리적으로 데이터파일)로부터 추가적인 공간을 할당받는데, 이때 정해진 익스텐트 크기의 연속된 블록을 할당받는다.  

`세그먼트` : 데이터 저장공간을 사용하는 오브젝트(테이블, 인덱스, 파티션, 클러스터, LOB 등)를 저장공간을 사용하지 않는 오브젝트(뷰, 시너님, 시퀀스, 함수, 프로시저, 트리거 등)와 구분해서 세그먼트라고 부른다. 저장공간을 사용한다는 것은 테이블스페이스로부터 한 개 이상의 익스텐트를 할당받음을 뜻한다. 세그먼트는 익스텐트의 집합이라고 말할 수 있는데, 익스텐트 내 블록이 논리적으로 서로 인접한 반면, 익스텐트끼리 서로 인접하지 않는다.  

`테이블스페이스` : 세그먼트를 담는 컨테이너로서, 여러 데이터파일로 구성된다. 각 세그먼트는 정확히 한 테이블스페이스만 속하지만, 한 테이블스페이스에는 여러 세그먼트가 존재할 수 있다. 한 세그먼트는 여러 데이터파일에 걸쳐 저장된다. 한 테이블스페이스가 여러 데이터파일로 구성되기 때문이다.

<br>
<br>

![Oracle 저장 구조](img/Oracle_저장구조.jpeg)

- 한 테이블스페이스에는 여러 세그먼트가 존재하므로 1:M 관계이다.
- 익스텐트는 블록의 집합이므로 익스텐트와 블록은 1:M 관계이다.
- 세그먼트는 익스텐트의 집합이므로 세그먼트와 익스텐트는 1:M 관계이다.

<br>

## Undo를 사용하는 목적

1) Transaction Rollback
2) Transaction Recovery (-> Instance Recovery 시 rollback 단계)
3) Read Consistency

## Redo 로그는 아래 3가지 목적을 위해 사용된다.

1) Database Recovery (=Media Recovery)
2) Cache Recovery(-> Instance Recovery 시 forward 단계)
3) Fast Commit

첫째, Redo 로그는 물리적으로 디스크에 결함이 생기는 등 Media Fail 발생 시 데이터베이스를 복구하기 위해 사용되며, 이때는 Archived Redo 로그를 이용하게 된다. `Media Recovery`라고도 한다.

둘째, Redo 로그는 Cache Recovery를 위해 사용되며 다른 말로 'Instance Recovery'라고도 한다.  
모든 데이터베이스 시스템이 I/O 성능을 위해 버퍼캐시를 사용하지만, 버퍼캐시는 휘발성이다.  
캐시에만 적용한 변경사항을 아직 데이터파일에 기록하지 않은 상태에서 정전 등이 발생해 인스턴스가 비정상적으로 종료되면, 그때까지의 작업 내용을 모두 잃게 된다.  
이러한 트랜잭션 데이터 유실에 대비하기 위해 Redo 로그를 남긴다.

셋째, Redo 로그는 Fast Commit을 위해 사용된다. 변경된 메모리 버퍼 블록을 데이터 파일에 기록하는 작업은 Random 액세스 방식으로 이루어지기 때문에 느리다.  
반면 로그는 Append 방식으로 기록하므로 훨씬빠르다.  
따르서 트랜잭션에 의한 변경사항을 건건이 데이터파일에 기록하기보다 우선 Append방식으로 빠르게 로그 파일에 기록하고, 버퍼캐시 블록과 데이터 파일 블록 간 동기화는 적절한 수단(DBWR, Checkpoint)을 이용해 나중에 일관(Batch) 수행한다.  

사용자가 요구한 갱신사항을 휘발성인 버퍼캐시에만 기록한 채 아직 디스크에 영구 기록하지 않았더라도 Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미로 'Fast Commit'이라는 용어를 사용한다.  
커밋 정보가 로그파일에 기록돼 있기만 하면, 인스턴스 Crash가 발생하더라도 Redo 로그를 이용해 언제든 복구 가능하므로 사용자 프로세스는 안심하고 커밋을 완료할 수 있다.

<br><br>

Redo 메커니즘

1. `Log Force at commit` : DML을 수행하는 사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경한다. 이후 Log Writer(LGWR)가 주기적으로 로그 버퍼 엔트리를 Redo 로그파일에 기록하는데, 메모리상의 로그 버퍼는 언제든 유실될 가능성이 있다.  
따리서 트랜잭션의 영속성을 보장하려면 최소한 커밋 시점에는 로그를 메모리가 아닌 데이터파일에 안전하게 기록해야 한다.

`Fast Commit` : 사용자가 요구한 갱신 사항을 휘발성인 버퍼캐시에만 기록한 채 아직 디스크에 영구 기록하지 않았더라도 Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미이다.  
커밋 정보가 로그파일에 기록돼 있기만 하면, 인스턴스 Crash가 발생하더라도 Redo 로그를 이용해 언제든 복구 가능하므로 사용자 프로세스는 안심하고 커밋을 완료할 수 있다.

`Write Ahead Logging` : 버퍼캐시 블록을 갱신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야 하며, DBWR가 버퍼캐시의 Dirty 블록들을 데이터 파일에 기록하기 전에 먼저 LGWR가 해당 Redo 엔트리를 모두 Redo 로그 파일에 기록했음이 보장되어야 한다.


<br><br>

- DB 특징

1. Sort Area는 SGA가 아니라 PGA 할당된다.
2. SQL은 라이브러리 캐시에 캐싱된다.


- 버퍼 블록의 상태

Free 버퍼 : 인스턴스 기둥 후 아직 데이터가 읽히지 않아 비어 있는 상태(clean 버퍼) 이거나, 데이터가 담겼지만 데이터파일과 서로 동기화돼 있는 상태에서 언제든지 덮어 써도 무방한 버퍼 블록을 말한다.  
오라클이 데이터파일로부터 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 한다. Free 상태인 버퍼에 변경이 발생하면 그 순간 Dirty 버퍼로 상태가 바뀐다. 

Dirty 버퍼 : 버퍼캐시에 적재된 이후 변경이 발생했지만, 아직 데이터파일에 기록하지 않아 동기화가 필요한 버퍼 블록을 말한다.  
이 버퍼 블록들을 다른 데이터 블록을 위해 재사용하려면 데이터파일에 먼저 기록해야 하며, 그 순간 Free버퍼로 상태가 바뀐다.

Pinned 버퍼 : 읽기 또는 쓰기 작업을 위해 현재 액세스되고 있는 버퍼 블록을 말한다.


<br><br>

- SQL 특징

1. 구조적 (structured)
2. 집합적 (set-based)
3. 선언적 (declarative)


- SQL 처리 과정

1) SQL 파싱  
사용자로부터 SQL을 전달받으면 가장 먼저 SQL 파서(Parser)가 파싱을 진행한다.
    - 파싱 트리 생성: SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
    - Syntax 체크 : 문법적 오류가 없는지 확인.
    - Semantic 채크 : 의미상 오류가 없는지 확인.

2) SQL 최적화  
옵티마이저가(Optimizer)가 이 역활을 한다.  
SQL 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후, 가장 효율적인 하나를 선택한다.

3) 로우 소스 생성  
SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계이다.  
로우 소스 생성기(Row-Source Generator)가 그 역활을 한다.

<br><br>

- SQL 최적화

사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 엑세스 경로를 선택해주는 DBMS의 핵심 엔진이다.  
  - 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 도출한다.
  - 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
  - 최저 비용을 나타내는 실행계획을 선택한다.


<br><br>

- 비용기반 옵티마이저

비용기반 옵티마이저는 사용자로부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획들을 찾아내서 각각의 예상 비용을 산정한 후 최저 비용을 나타내는 하나를 선택한다.

<br><br>

## 옵티마이저 힌트

옵티마이저는 힌트는 명령어이므로 특별한 이유가 없는 한 그대로 실행된다.

1. 문법적으로 맞지 않게 힌트를 기술
2. 잘못된 참조 사용 : 없는 테이블, 없는 인덱스 사용
3. 논리적으로 불가능한 액세스 경로
4. 의미적으로 맞지 않게 힌트를 기술  
-> 동치절(=)이 하나도 없는데 해시 조인으로 유도
5. 옵티마이저에 의해 내부적으로 쿼리가 변환된 경우  
-> 서브쿼리에 unnest 와 push_subq를 같이 기술
6. 버그


- 힌트 안에 인자를 나열할 땐, ','(콤마)사용할 수 있지만, 힌트와 힌트 사이에 사용하면 안 된다.
- 테이블을 지정할 때 스키마명까지 명시하면 안된다.
- FROM절 테이블명 옆에 ALIAS를 지정했다면, 힌트에도 반드시 ALIAS를 사용해야 한다.


### 자주 사용하는 힌트 목록

<table>
    <thead>
        <tr>
            <th>분류</th>
            <th>힌트</th>
            <th>설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2">최적화<br>목표</td>
            <td>ALL_ROWS</td>
            <td>전체 처리속도 최적화</td>
        </tr>
        <tr>
            <td>FIRST_ROWS(N)</td>
            <td>최초 N건 응답속도 최적화</td>
        </tr>
    </tbody>        
</table>

