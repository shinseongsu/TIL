# 인덱스 튜닝

## B*Tree 튜닝

- 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다.
- 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다.
- 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다.
- 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다.
- 리프 블록의 각 로우와 테이블 로우 간에 1:1 관계이다.
- 리프 블록끼리는 이중연결리스트(double linked list) 구조이다.

## 인덱스 ROWID

오라클 초기 버전에는 `제한 ROWID 포맷`은 `ROWID가 데이터파일 + 블록번호 + 블록 내 로우번호`로 구성된다.  
오라클 8 버전부터 `확장 ROWID 포맷`은 `오브젝트 번호 + 데이터파일 번호 + 블록 번호 + 블록 내 로우번호`

## 인덱스 탐색 

B*Tree 인덱스를 탐색할 때는 우선 루트에서 리프 블록까지 수직적 탐색을 통해 스캔 시작지점을 찾는다.  
수직적 탐색을 통해 조건을 만족하는 첫 번째 레코드를 찾았으면, 인덱스 리프 블록을 스캔하면서 찾고자 하는 데이터가 더 안 나타날 때까지 수평적 탐색을 진행한다.


## 인덱스 사용

```sql
[ 인덱스 구성 ]
고객_PK : 고객번호
고객_X1 : 가입일자 + 성별 + 고객명

SELECT /*+ ___  */ 고객번호, 성별, 가입일자, 연락처
  FROM 고객 C
 WHERE 고객명 = :CUST_NM
   AND 가입일자 BETWEEN :ENT_DT1 AND :ENT_DT2 

사용가능 한 인덱스 사용법

INDEX(C)
INDEX(C 고객_X1)
INDEX(C(가입일자))

INDEX(C(가입일자, 고객명)) -> x 사용할수 없음  
가입일자 + 고객명 선두로 한 인덱스가 없어 무시될수 있다. 인덱스가 사용되어도 Table Full Scan이 될 수 있기 때문에 정답은 아니다.

```

## SQL Server Index 사용법

```sql
고객_PK : 고객번호(클러스터형 인덱스)

DECLARER @CUST_NO INT

1.
SELECT *
  FROM 고객 WITH( FORCESEEK( 고객_PK (고객번호)))
 WHERE 고객번호 = @CUST_NO
 
2.
SELECT *
  FROM 고객
 WHERE 고객번호 = @CUST_NO
 OPTION (INDEX(고객_PK)) 

```

## Index Range Scan

- B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 스캔 방식이다.
- 인덱스 루트에서 리프 블록까지 수직 탐색한 후에 리프 블록을 수평 탐색하는 방식이다.
- 수평 탐색 범위는 인덱스 구성, 조건절 연산자에 따라 달라진다.
- WHERE 절에 선두 컬럼이 있어야한다. 하지만 , 꼭 = 일 필요는 없고 LIKE, 부등호, LIKE 모두 가능하다.

## INDEX FULL SCAN

Index Full Scan은 인덱스 리프 블록을 처음부터 끝까지 모두 스캔하는 방식이며, `인덱스 선두 컬럼이 조건절에 없을 떄` 사용한다.

인덱스 선두 컬럼이 조건절에 없으면 Index Range Scan이 불가능하므로 테이블을 Full Scan해야 하는데, 컬럼이 많은 큰 테이블을 스캔하려면 블록 I/O가 많이 발생하므로 성능이 느리다.  
-> 컬럼이 적은 인덱스를 스캔하면 I/O 발생량을 줄일 수 있다. 단, 인덱스 필터 조건을 만족하는 데이터가 적어야 한다. 필터 조건을 만족하는 데이터가 많으면 테이블 랜덤 액세스도 그만큼 많이 발생하므로 테이블 전체 스캔보다 성능이 훨씬 느려진다.

필터 조건을 만족하는 데이터가 많더라도 결과집합 중 앞쪽 일부만 스캔하고 멈춘다면, 즉 부분범위 처리를 활용할 수 있다면, Index Full Scan이 효과적일 수 있다. 인덱스 앞쪽에서 조건을 만족하는 데이터를 빨리 찾을 수 있기 때문이다.

## INDEX UNIQUE SCAN

```sql
주문상품_PK : 주문일자 + 고객ID + 상품ID

SELECT 상품ID, 주문수량, 주문가격, 할인률
  FROM 주문상품
 WHERE 주문일자 = :ord_dt
   AND 고객ID  = :cust_id  
```

인덱스 구성 컬럼을 모두 '=' 조건으로 검색하면 Index Unique Scan이 선택되지만, 전체가 아닌 일부 컬럼으로 검색할 때는 Range Scan이 선택된다.


## INDEX Fast Full Scan

- Multiblock I/O 방식을 사용한다.
- 병렬 스캔도 가능하다.
- `인덱스에 포함된 컬럼으로만 조회 할 때` 사용할 수 있다.
- 인덱스 리프 블록끼리 논리적 연결 순서를 따르지 않고 Table Full Scan처럼 HWM 아래 익스텐트 전체를 Multiblock I/O 방식으로 Full Scan 하므로 결과 집합의 순서를 보장하지 않는다.


## Index Skip Scan

- 인덱스 선두 컬럼이 조건절에 없을 때 사용할 수 있는 스캔 방식 중 하나다.
- 인덱스 선두 컬럼이 조건절에 있을 때도 사용할 수 있다.
- INDEX_SS 힌트로 유도한다.

### 연습문제

```sql
ALTER TABLE 고객 ADD CONSTRAINT 고객_PK PRIMARY KEY(고객번호);
CREATE INDEX 고객_X01 ON 고객(고객등급, 연령);


SELECT 고객번호, 고객명, 가입일시, 고객등급, 연령, 연락처
  FROM 고객
 WHERE 연령 BETWEEN 20 AND 40
 ORDER BY 고객번호; 
```

-> 선두 컬럼이 WHERE 절에 없어 INDEX RANGE SCAN은 안된다.  
인덱스에 없는 컬럼을 포함하므로 Index Fast Full Scan은 불가능하다.  
고객등급 NDV가 적을수록 Skip Scan이 유리하다.

### 연습문제 2

```sql
ALTER TABLE 고객 ADD CONSTRAINT 고객_PK PRIMARY KEY(고객번호);
CREATE INDEX 고객_X01 ON 고객(연령, 고객명);

SELECT 고객번호, 고객명, 가입일시, 고객등급, 연령, 연락처
  FROM 고객
 WHERE 연령 BETWEEN 20 AND 40
   AND 고객명 = '홍길동'
ORDER BY 고객번호; 

```

-> 고객_PK를 사용하도록 힌트로 유도하면 고객번호가 조건절에 없으므로 INDEX FULL SCAN하게 된다.  
고객_X01를 사용하면 선두컬럼인 연령이 조건절에 있으므로 Index Range Scan이 가능하다. Index Skip Scan도 가능하다.  

동명이인이 거의 없다면 Range Scan 보다 Skip Scan이 유리하다.  
고객_X01 선두컬럼 연령이 조건절에 있으므로 Index Full Scan은 불가능하다.


### Index Skip Scan 문제 

Index Skip Scan은 NDV가 적은 인덱스 선두 컬럼이 조건절에 없을 때 유용한 스캔 방식인데, NDV가 적은 두 개의 선두컬럼이 모두 조건절에 없을 때도 사용할 수 있다.  

선두 컬럼이 부등호, BETWEEN, LIKE 같은 범위검색 조건일 때도 Index Skip Scan을 사용 할 수 있다.
IN일 경우에는 사용할 수 없다.

## B*Tree 인덱스에서 생길 수 있는 현상 

- Index Skew : 인덱스 엔트리가 왼쪽 또는 오른쪽으로 치우치는 현상을 말한다.
- Index Sparse : 인덱스 블록 전반에 걸쳐 밀도(density)가 떨어지는 현상을 말한다.
- Index Fragmentation : 디스크 상에 Page들이 연속적으로 위치해 있지 않고(서로 연관된 데이터들이 한 Extent로 묶이지 않는), 공간을 두고 떨어져 있는 현상

## 비트맵(Bitmap) 인덱스

비트맵 인덱스는 성별처럼 Distinct Value 개수가 적을 때 저장효율이 매우 좋다. 그런 컬럼이면 B*Tree 인덱스보타 훨씬 적은 용량을 차지하므로 인덱스가 여러 개 필요한 대용량 테이블에 유용하다.

비트맵 인덱스는 여러 인덱스를 동시에 사용할 수 있다.  
여러 개 비트맵 인덱스로 Bitwise연산을 수행함으로써 테이블 엑세스랑 크게 줄일 수 있다면 극적인 성능 향상을 가져다 준다.  
따라서, 다양한 조건절이 사용되는 특히 정형화되지 않은 임의 질의가 많은 대용량 DW/OLAP 환경에 적합하다.  

다만, 비트맵 인덱스는 Lock에 의한 DML 부하가 심한 것이 단점이다. 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 lock이 걸린다.  
OTLP성 환경에 비트맵 인덱스를 쓸 수 없는 이유가 바로 여기에 있다.


## 함수기반 인덱스

조건절에서 인덱스 컬럼에 함수를 적용하면 정상적인 Index Range Scan이 불가능하다.  
인덱스에는 가공하지 않은 값을 기준으로 정렬해서 저장했는데, 가공한 값으로 검색하면 수직적탐색을 통해 스캔 시작점과 끝 지점을 찾을 수 없기 때문이다.  
인덱스에도 함수를 적용한 상태로 저장하면 정상적인 Index Range Scan이 가능한데, 이것을 함수기반 인덱스라고 한다.

```sql
SELECT * FROM 고객 WHERE REPLACE(전화번호, '-', '') = :PHONE_NO
```

## 리버스 키(Reverse Key) 인덱스

일련번호, 입력일시, 변경일시 등 오름차순 한 방향으로만 값이 증가하는 컬럼에 인덱스를 생성하면, 동시에 INSERT 하려는 다중 트랜잭션에 의해 우측(마지막)에 경합이 발생할 수 있다. 그럴 때 인덱스 키 값을 역으로(reverse) 변환해서 지정하면 신규 INSERT하는 값들이 여러 리프 블록에 흩어지므로 경합도 자연스럽게 줄어든다.  

리버스 키 인덱스를 생성하는 방법
```sql
CREATE INDEX HOT_TABLE_R1 ON HOT_TABLE( RIGHT_GROWING_COL ) REVERSE; 

CREATE INDEX HOT_TABLE_R1 ON HOT_TABLE( REVERSE(RIGHT_GROWING_COL));


SELECT * FROM HOT_TABLE A
WHERE REVERSE(RIGHT_GROWING_COL) = REVERSE(:KEYWORD)
```

### 여러 인덱스 특징 ( 랜덤 액세스를 줄일 수 있다.)

- IOT는 테이블을 인덱스 구조로 관리한다. 일반 힙(Heap) 구조 테이블은 값을 무작위로 입력하지만, IOT는 지정한 키 값 순으로 정렬 상태를 유지한다. 키 값 이외의 컬럼도 모두 인덱스 리프 블록에 저장하므로 테이블 랜덤 액세스가 전혀 발생하지 않는다.

- 클러스터는 값이 같은 레코드를 한 블록(데이터 많을 경우 연결된 여러 블록)에 모아서 저장하므로 인덱스를 이용한 테이블 랜덤 액세스를 줄이는데 도움을 준다.

- 테이블 파티션은 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장한다. 따라서 특정 조건을 만족ㄱ하는 데이터를 인덱스를 이용한 랜덤 액세스가 아닌 full Scan 방식으로 빠르게 찾을 수 있다.


## IOT(Index-Organized Table)

- IOT는 PK순으로 정렬 상태를 유지하는 테이블이다.  
일반 속성이 없꼬 PK가 테이블 IOT로 구성하면, 별도 PK 인덱스를 생성하지 않아도 되므로 공간을 절약할 수 있고 Insert 성능도 높일 수 있다.

- 일자순으로저장하고 PK끼리 모아서 저장하므로 조회하는 성능쿼리를 높일 수 있다.

- 일자 순으로 정렬되도록 IOT를 구성하면, 한 달 이상 넓은 범위로 조회하더라도 테이블 랜덤 액세스가 전혀 발생하지 않아 빠른 조회가 가능하다.

- 일반적인 속성을 IOT 리프 블록에 저장할 경우, 인덱스 Dept가 증가하고 블록 I/O를 증가시킴으로써 랜덤 엑세스 감소 효과를 상쇄한다.

- SQL server 클러스트형 인덱스는 PK가 아닌 컬럼으로도 생성할 수 있다.

- 클러스터형 인덱스는 데이터를 정렬하는 기준을 정의하는 기능이므로 테이블에 한 개만 생성할 수 있다. (Oracle, SQL server 둘다)


### Index Range Scan 불가 조건

인덱스를 정상적으로 Range Scan 할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다.  
일정 범위를 스캔하려면 '시작지점' 과 '끝지점'이 있어야한다.

- 중간 값 검색(양쪽 % LIKE 조건) 하는 경우
- 부정형 비교 조건인 경우
- 인덱스 컬럼을 변경하는 경우
- NVL() 같은 경우는 값에 따라 인덱스 Range Scan 가능 여부가 결정된다.


### IS NULL 조건에 대한 Index Range Scan

오라클 구성 컬럼이 모두 NULL인 레코드는 인덱스에 저장하지 않습니다. 따라서 단일 컬럼에 생성한 인덱스에 대한 IS NULL 조건으로 Index Range Scan이 불가능하다.  
2개 이상 컬럼으로 구성된 결합 인덱스에 대해서는 IS NULL 조건에 대한 Index Range Scan이 가능하다. 구성 컬럼 중 하나라도 NULL이 아닌 레코드는 인덱스에 저장하기 때문이다.


### Index Range Scan 가능 조건

인덱스를 Range Scan 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

조건절이 NOT BETWEEN 조건인경우 CONCATENATION(옵티마이저에 의한 UNION ALL 분기)가 일어나면 RangeScan이 가능하다.  
참고로, CONCATENATION을 유도하려면 USE_CONCAT 힌트를 쓰면 된다.

OR 조건은 기본적으로 Index Range Scan을 위한 엑세스 조건으로 사용할 수 없다.

-> 인덱스에 없는 컬럼을 쓸경우 Table Full Scan을 하게 된다.


## OR 조건에 대한 Index Range Scan

OR 조건은 기본적으로 Index Range Scan을 위한 액세스 조건으로 사용할 수 없다. OR 조건으로는 수직적 탐색을 통해 스캔 시작점을 찾을 수 없기 때문이다.  
다만, CONCATENATION(옵티마이저에 의한 UNION ALL 분기)으로 처리했을 때 각각 수직 탐색을 위한 엑세스 조건으로 사용할 인덱스가 있다면, Index Range Scan이 가능하다.


#### Index Range 만들기 연습문제

```sql
[ 모법 1 ]

select 주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
 from 주문
where 주문상태코드 in (0, 1, 2, 3, 4, 5)
  and 주문일자 between :dt1 and :dt2

[ 모법 2 ]

select 주문번호, 주문일시, 고객 ID, 총주문금액, 처리상태
  from 주문
 where 주문상태코드 in ( select 주문상태코드
                        from 주문상태
                       where 주문상태코드 <> 3 )
   and 주문일자 between :dt1 and :dt2


[ 모법 3 ]

select /*+ no_merge(a) ordered use_nl(b) */
       주문번호, 주문일시, 고객 ID, 총주문금액, 처리상태
  from ( select 주문상태코드
           from 주문상태
          where 주문상태코드 <> 3 ) a, 주문 b
 where b.주문상태코드 = a.주문상태코드
   and b.주문일자 between :dt1 and :dt2             


[ 모법 4 ]

select /*+ USE_CONCAT */
       주문번호, 주문일시, 고객 ID, 총주문금액, 처리상태
  from 주문 
 where ( 주문상태코드 < 3 or 주문상태코드  )
   and 주문일자 between :dt1 and :dt2

[ 모범 5 ]

select 주문번호, 주문일시, 고객 ID, 총주문금액, 처리상태
  from 주문
 where 주문상태 < 3
   and 주문일자 between :dt1 and :dt2
union all
select 주문번호, 주문일시, 고객 ID, 총주문금액, 처리상태   
  from 주문
 where 주문상태코드 > 3
   and 주문일자 between :dt1 and :dt2   

```


### Index Range Scan 유도하기 연습문제

```sql
[인덱스 구성]
월말계좌상태_PK: 계좌번호 + 계좌일련번호 + 기준년월
월말계좌상태_X1: 기준년월 + 상태구분코드

[수정할 SQL]
UPDATE 월별계좌상태 SET 상태구분코드 = '07'
 WHERE 상태구분코드 <> '01'
   AND 기준년월 = :BASE_DT
   AND 게좌번호 || 계좌일련번호 IN
       ( SELECT 게좌 번호 || 게좌일련번호
           FROM 계좌원장
          WHERE 개설일자 LIKE :STD_YM || '%' )

[수정 SQL ]
UPDATE 월별계좌상태 SET 상태구분코드 = '07'
 WHERE 상태구분코드 <> '01'
   AND 기준년월 = :BASE_DT
   AND (계좌번호, 계좌일련번호) IN 
       ( SELECT 계좌번호, 계좌일련번호
           FROM 계좌원장
          WHERE 개설일자 LIKE :STD_YM || '%' )

```


### Index Range Scan 유도하기 문제 - 2

```sql
[ 데이터 타입 ]
지수구분코드 VARCHAR2(1)
지수업종코드 VARCHAR2(3)

[ 인덱스 구성 ]
일별지수업종별거래_PK : 지수구분코드 + 지수업종코드 + 거래일자
일별지수업종별거래_X1 : 거래일자

[ 수정할 SQL ]
SELECT 거래일자
     , SUM(DECODE(지수구분코드, '1', 지수종가, 0)) KOSPI200_IDX
     , SUM(DECODE(지수구분코드, '1', 누적거래량, 0)) KOSPI200_IDX_TRDVOL
     , SUM(DECODE(지수구분코드, '2', 지수종가, 0)) KOSDAQ_IDX_TRDVOL
  FROM 일별지수업종별거래 A
 WHERE 거래일자 BETWEEN :startDd AND :endDd
   AND 지수구분코드 || 지수업종코드 IN ('1001', '2002')
 GROUP BY 거래일자


[ 수정 SQL ]
SELECT /*+ USE_CONCAT */
       거래일자
     , SUM(DECODE(지수구분코드, '1', 지수종가, 0)) KOSPI200_IDX
     , SUM(DECODE(지수구분코드, '1', 누적거래량, 0)) KOSPI200_IDX_TRDVOL
     , SUM(DECODE(지수구분코드, '2', 지수종가, 0)) KOSDAQ_IDX_TRDVOL
  FROM 일별지수업종별거래 A
 WHERE 거래일자 BETWEEN :startDd AND :endDd
   AND (지수구분코드, 지수업종코드) IN (('1', '001'), ('2', '003'))
 GROUP BY 거래일자

```

### 아래 쿼리를 튜닝하라

```sql
[ 인덱스 구성 ]
주문_PK : 주문일자 + 주문번호

[ SQL ]
SELECT NVL(MAX(주문번호 + 1), 1)
  FROM 주문
 WHERE 주문일자 = :주문일자 

[ 실행계획 ]
SELECT STATEMENT Optimizer=ALL_ROWS
  SORT (AGGREGATE)
    INDEX (RANGE SCAN) OF '주문_PK' (INDEX (UNIQUE))



==> 튜닝 후, 실행계획

SELECT STATEMENT Optimizer=ALL_ROWS
  SORT (AGGREGATE)
    FIRST ROW
      INDEX (RANGE SCAN (MIN/MAX)) OF'주문_PK' (INDEX)

```

## 테이블 액세스 최소화

인덱스 ROWID는 테이블 레코드와 직접 연결된 구조가 아니다. 데이터파일상에서 테이블 레코드를 찾아가기 위한 논리적인 주소 정보이다.  
인덱스 ROWID에 포함된 데이터 블록 주소(= 데이터파일번호 + 블록번호)는 디스크 상의 블록 주소지만, 블록을 매번 데이터파일에서 읽는다면 성능은 이루 말할 수 없이 느리다.  
I/O 성능을 위한 버퍼캐시 활용이 필수인 이유다. ROWID가 가리키는 블록을 버퍼캐시에서 먼저 찾아보고, 못 찾을 떄만 데이터파일에서 읽는다. 물론 버퍼캐시에 적재한 후에 읽는다.

캐시에서 블록을 읽을 때는 읽고자 하는 데이터 블록 주소를 해시 함수에 입력해서 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다. 캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로 버퍼 헤더는 항상 같은 해시 체인에 연결된다. 반면, 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱되는데, 그 메모리 주소값을 버퍼 헤더가 가지고 있다.

버퍼캐시는 시스템 공유 메모리에 위치하므로 액세스를 직렬화하기 위한 Lock 매커니즘이 작동한다. 따라서 버퍼캐시에서 블록을 읽을 때마다 Latch와 Buffer Lock을 획득해야 한다.  
동시 액세스가 심할때는 Latch와 Buffer Lock에 대한 경합까지 발생하므로 인덱스 ROWID를 이용한 테이블 액세는 생각보다 고비용 구조다.


## 인덱스 손익분기점

1. 인덱스 클러스터링 팩터가 좋으면 테이블 액세스 과정에 발생하는 블록 I/O가 감소하므로 같은 양의 데이터를 추출하더라도 CF가 나쁠 때보다 소요 시간이 줄어든다.  
따라서 그래프에서 인덱스 ROWID를 이용한 테이블 액세스의 경사가 완만해지면서 인덱스 손익분기점이 올라간다. 반대로 CF가 나쁘면 인덱스 ROWID를 이용한 테이블 액세스의 경사가 가팔라지면서 인덱스 손익분기점은 내려간다.

2. Multiblock I/O 단위를 늘릴수록 디스크 I/O Call 횟수가 줄고 테이블 전체 스캔 비용이 낮아지므로 소용시간이 줄어든다. 따라서 인덱스 손익분기점이 내려간다.

3. 테이블 스캔 비용은 데이터양이 느는 만큼 선형적으로 증가하지만, 인덱스를 이용한 테이블 액세스 비용은 데이터양이 늘고 추출 건수가 많아질수록 기하급수적으로 증가한다.  
첫 번쨰 이유는 데이터양이 늘수록 인덱스 CF가 점점 나빠지기 떄문이다.  
두 번쨰 이유는 버퍼캐시 히트율이 점점 낮아지기 때문이다. 버퍼캐시에 적재할 데이터가 많은데, 버퍼캐시 크기는 일정하다. 따라서 테이블이 커질 수록 블록을 버퍼캐시에서 찾을 가능성은 작아진다.  
Multiblock I/O 효과까지 고려하면, 데이터가 늘 때의 Full Scan 비용 상승보다 방금 설명한 두 가지 요소에 의한 테이블 랜덤 액세스 비용 상승이 일반적으로 더 크다. 따라서 데이터양이 늘수록 인덱스 손익분기점은 내려갈 가능성이 높다.


## 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활요하는 것이 무엇보다 중요하다. 조인도 대부분 NL 방식을 사용한다. 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구형할 수 있다면, 온라인 환경에서 대량 데이터를 조회할 떄도 아주 빠른 응답 속도를 낼 수 있다.  

반면, 대량 데이터를 읽고 갱신하는 배치(Batch) 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다. 즉, 처리대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 한다. 대량 데이터를 빠르게 처리하려면, 인덱스와 NL 조인보다 Full Scan과 해시 조인이 유리하다.


## 아래와 같은 상황에서 인덱스 구성 변경에 따른 운영 리스크와 애플리케이션 영향도를 최소하면서도 쿼리 성능을 높이는 가장 합리적인 튜닝 방안을 고르시오.

```sql
> 로밍렌탈_N2 인덱스 : 서비스번호 + 사용여부

SELECT 렌탈관리번호, 고객명, 서비스관리번호, 서비스번호, 예약접수일시
     , 방문국가코드, 로밍승인번호, 자동로밍여부
  FROM 로밍멘탈
 WHERE 서비스번호 LIKE '010%'
   AND 사용여부 = 'Y'
   AND 자동로밍여부 = 'N'

Table Access By INDEX ROWID 로밍렌탈
  INDEX RANGE SCAN 로밍렌탈_N2    

```

- 인덱스를 스캔하고서 얻은 건수는 266,476 이다. 따라서 그 건수만큼 테이블을 랜덤 액세스했는데, 그 단계에서만 265,957(=266,968-1,011)개 블록을 읽었다. 이는 전체 블록 I/O 99.6%를 차지하는 양이다.  
문제는 테이블을 총 266,476번 방문했지만, 최종 결과집합이 1,990건뿐이라는데 있다. 테이블 방문하고서 자동로밍여부 = 'N' 조건을 체크하는 과정에서 대부분 걸러지는 것이다.  

- 정답 : 로밍렌탈_N2 인덱스를 서비스번호 + 사용여부 + 자동로밍여부 로 변경한다.

해결방안으로 "사용여부 + 자동로밍여부 + 서비스번호"로 구성된 신규 인덱스를 생성하는 방안도 고려해 볼 수 있으나, 인덱스 추가로 인해 DML 성능이 나빠지게 된다. 따라서 성능을 크게 향상시킬 수 있는 경우가 아니면, 가급적이면 인덱스를 추가하지 않고 기존 인덱스를 활요해 성능을 높이는 방안을 우선해서 고랴해야 한다.


## 테이블 랜덤 액세스가 많아서 성능이 느린경우 고려할 방안

1. 인덱스에 컬럼을 추가하는 방안을 검토한다.
2. IOT(인덱스 구조 테이블)로 변경하는 방안을 검토한다. 다만, 테이블 구조변경에 따른 부담과 IOT 자체가 갖는 부작용이 적지 않으르므로 운영중에 적용하고자 할 때는 신중하게 검토해야 한다.
3. 인덱스 순으로 정렬되도록 테이블을 재생성하는 방안을 건토한다.

## 인덱스 뒤쪽에 컬럼을 추가했을 나타날수 있는 현상

인덱스에 컬럼을 추가하면 인덱스 사이즈가 증가한다. 한 블록에 담을 수 있는 로우 수가 줄면 리프 블록 수가 증가하고, 인덱스 높이도 증가하기 때문이다. 리프 블록 숙가 증가하면 스캔 과정에 읽은 블록 I/O가 다소 증가하므로 스캔 효율이 약간 나빠진다.  
값이 깥은 인덱스 레코드는 ROWID 순으로 정렬하므로 선두 컬럼의 NDV가 적다면 클러스터링팩터는 비교적 좋은 상태일 껏이다. 이때 뒤쪽에 컬럼을 추가하면 새로운 정렬 순서(기존 컬럼 + 신규 컬럼 + ROWID)를 갖게 되므로 클러스터링 팩터가 나빠진다. 선두 컬럼의 NDV가 많은 상황에서 컬럼을 추가하더라도 클러스터링 팩터가 좋아지지는 않는다.


## 실행계획이 옵티마이저에 의해 갑자기 아래와 같이 변경될 때 나타날 수 있는 현상

```sql
[ 변경 전 실행계획 ]
SELECT STATEMENT
  TABLE ACCESS BY INDEX ROWID
    INDEX RANGE SCAN


[ 변경 후 실행계획 ]
SELECT STATEMENT
  TABLE ACCESS BY INDEX ROWID BATCHED
    INDEX RANGE SCAN

```

인덱스 ROWID를 이용한 테이블 랜덤 액세스는 생각보다 고비용 구조다. 인덱스를 이용해 대량 데이터를 조회하면, 디스크 I/O 발생량이 증가하고 그만큼 성능이 나빠진다. 디스크 랜덤 I/O 성능을 높이려고 DBMS 업체들이 계속 노력을 기울이는 가운데, 오라클에서 최근 가장 눈에 띄는 개선은 배치 I/O 기능에서 찾을 수 있다.  

배치(Batch) I/O는 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능이다. 인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 일반적으로 디스크 블록을 바로 읽는데, 이 기능이 작동하면 테이블 블록에 대한 디스크 I/O Call 미뤘다가 읽은 블록이 일정량 쌓이면 한꺼번에 처리한다.

배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다는 사실에 주목해야한다. 테이블 블록을 모두 버퍼 캐시에서 찾을 때는(버퍼캐시 히트율 = 100%) 기존처럼 인덱스 키값 순으로 데이터가 출력되지만, 그렇지 않을 때 즉, 실제 배치 I/O가 작동할 떄는 출력 순서가 인덱스 정렬 순서와 다를 수 있다.


## SQL 실행계획이 옵티마이저에 의해 아래와 같이 변경될때 현상

```sql

> EXP_X01 인덱스 : DEPTNO + JOB + EMPNO

SELECT * FROM EMP WHERE DEPTNO = 20 ORDER BY JOB, EMPNO;

[ 변경 전 실행계획 ]
SELECT STATEMENT
  TABLE ACCESS BY INDEX  ROWID
    INDEX RANGE SCAN

[ 변경 후 실행계획 ] 
SELECT STATEMENT
  SORT ORDER BY
    TABLE ACCESS BY INDEX ROWID BATCHED
      INDEX RANGE SCAN

```

소트 연산을 생략할 수 있는 인덱스 구성이므로 배치 I/O가 작동하지 않는 한 '변경 전 실행계획'처럼 'SORT ORDER BY' 오퍼레이션이 자동으로 생략된다.  
소트 연산을 생략할 수 있는 인덱스 구성이어도 배치 I/O가 작동할 수 있다면 '변경 후 실행계획' 처럼 SORT ORDER BY 오퍼레이션이 나타난다. 배치 I/O가 실제로 작동하면 데이터 정렬 순서를 보장 할 수 없게 되므로 옵티마이저가 정렬 연산을 추가한 것이다. 배치 I/O가 작동하더라도 SQL에 ORDER BY를 명시했으므로 정렬 순서는 보장된다, 다만, 부분범위 처리가 불가능해진다.


## 인덱스 스캔 효율화


### 인덱스 튜닝의 두가지 핵심 요소

세부적인 인덱스 튜닝 방법으로 여러가지가 있지만, 핵심요소는 두 가지로 나뉜다.  

첫 번째는 인덱스 스캔 꽈정에서 발생하는 비율을 줄이는 것이다. 즉, '인덱스 스캔 효율화 튜닝' 이다. 효율이란 들인 노력과 얻은 결과의 비율이다. 인덱스를 스캔한 양에 비해 얻은 결과 건수가 적으면 비효율이다.  

두 번째 핵심요소는 테이블 액세스 횟수를 줄이는 것이다. 인덱스 스캔 후 테이블 레코드를 액세스 할 때 랜덤 I/O 방식을 사용하므로 이를 '랜덤 액세스 최소화 튜닝' 이라고 한다. 테이블을 액세한 양에 비해 얻은 결과 건수가 적으면 비효율적이다.


### 스캔 과정에서 비효율이 가장 큰 조건절을 고르시오.

`인덱스 구성 : 상품유형코드 + 업체코드 + 상품코드 + 할인구분코드`

테이블과 달리 인덱스에는 '같은 값'을 갖는 레코드들이 서로 군집해 있다. '같은 값'을 찾을 때 '=' 연산자를 사용하므로 인덱스 컬럼을 앞쪽부터 누락ㄱ 없이 '=' 연산자로 조회하면 조건절을 만족하는 레코드가 모두 모여 있다. 따라서 인덱스 스캔 효율은 인덱스 컬럼이 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다. 인덱스 컬럼 중 일부가 조건절에 없거나 '=' 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.  

인덱스 선행 컬럼 중 어느 하나가 조건절에 없거나 '=' 조건이 아닌 연산자로 조건절을 만족하는 레코드가 서로 흩어진 상태가 된다. 결국, 선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.  
따라서 스캔하는 단계에서 비효율이 생긴다.



### 효과적인 튜닝 방안

```sql
> 인덱스 구성 : 할인구분코드 + 상품코드 + 업체코드 + 상품유형코드

SELECT 주문일자, 상태코드, 정상가, 할인가, 할인구분코드
  FROM 상품공급
 WHERE 상품유형코드 = 'A'
   AND 업체코드 = 'Z956'
   AND 상품코드 = 'A0113509056'
   AND 할인구분코드 BETWEEN 'A' and 'C'
 ORDER BY 주문일자 DESC
```

- 인덱스 최 선두 컬럼인 할인구분코드가 BETWEEN 조건이므로 인덱스 스캔 효율이 매우 좋지 않은 상황이다. 할인구분코드가 'A'와 'C' 사이에 속한 구간을 모두 스캔하면서 나머지 상품코드, 업체코드, 상품유형코드 조건을 필터링하기 떄문이다.


할인구분코드는 NDV가 적은 반면 상품코드는 NDV가 많으므로 INDEX SKIP Scan이 매우 효과적이다.  
선두 컬럼의 NDV는 적고 후행 컬럼의 NDV는 많을 때 BETWEEN 조건의 인덱스 선두 컬럼을 IN 조건으로 변경하면 성능 향상에 큰 도움이 되며, 가장 흔히 사용하는 튜닝기법이다.


### SQL에 대한 튜닝 방안으로 가장 적절한것은?

```sql
> 데이터 분포
  - 월별로 100만 개 레코드 저장
  - 총 10년치 데이터 보관
  - 판매구분코드가 'A'로 시작하는 데이터는 2%

> 인덱스 구성
  - 월별고객별판매집계_IDX2 : 판매월 + 판매구분코드

SELECT COUNT(*)
  FROM 월별고객별판매집계
 WHERE 판매구분코드 LIKE 'A%'
   AND 판매월 BETWEEN '202001' AND '202012'     


SORT AGGREGATE
  INDEX RANGE SCAN 월별고객별판매집계_IDX2

```

- INDEX SKIP SCAN으로 유도한다.
- 판매월 BETWEEN 조건절을 IN-LIST로 변경한다.
- 월별고객별판매집계_IDX2 인덱스를 "판매구분코드 + 판매월" 순으로 변경한다.

## Index Range Scan으로 처리는 아 두 쿼리를 Index Skip Scan으로 유도했을 때의 성능 효과를 설명한것은?

```sql
> 하루 승인요청 건수는 100만건

< 쿼리 1 >
> 인덱스 : 승인요청일시 + 승인요청자ID

SELECT COUNT(*)
  FROM 승인요청
 WHERE 승인요청일시 >= trunc(sysdate- 6)
   AND 승인요청자ID = :reqr_id;

< 쿼리 2 >
> 인덱스 : 승인요청일자 + 승인요청자ID

SELECT COUNT(*)
  FROM 승인요청
 WHERE 승인요청일자 >= to_char(sysdate-6, 'yyyymmdd')
   AND 승인요청자ID = :reqr_id; 

```

- 쿼리 2에서 승인요청일자는 값 종류가 7개이고 매일 100만 건이 존재하는 상황이므로 각 일자 구간에서 특정 승인요청자ID의 데이터를 찾을 때는 Index Range Scan이 큰 동운을 준다.

반면, 쿼리 1에서 하루는 86,400초이므로 7일간 승인요청일시로 가능한 값의 종료는 최대 604,800개이다. 최대 604,800개 값 구간에 구간에 흩어진 특정 승인요청자ID의 데이터를 찾을 때 Index Skip Scan은 성능 향상에 전혀 도움이 되지 않는다.


## 주문상세 테이블에 보기와 같이 4개의 인덱스가 있다. 아래 쿼리를 위해 가장 효과적인 인덱스를 고르시오.

```sql

1. 주문 테이블 : #고객번호 + #주문일자 + #주문순번 + *결제수단코드 + ...

2. 주문상세 : #고객번호 + #주문일자 + #주문순번 + #상품ID = *주문수량 + ...

> 주문당 평균 20개 상품을 구매

SELECT *
  FROM 주문상세
 WHERE 고객번호 = :cust_no
   AND 주문일자 = :ord_dt
   AND 상품ID IN ( 'NH0037', 'PW73828', 'KR00050', 'ZQ7412' ) 
```

`주문상세_PK : 고객번호 + 주문일자 + 주문순번 + 상품ID`

- 고객번호와 주문일자 조건을 만족하는 데이터를 스캔하면서 상품ID 조건을 필터링한다.   
한 고객이 주문당 평균 20개 상품을 구매하므로 주문상세 레코드는 20개에 불과하고, 하루에 3~5회 주문해도 60~100개에 불과하다. 인덱스 리프 블록 하나에 모두 담을 수 있는 양이므로 인덱스 높이가 3이면 3개 블록만 읽으면 된다.


## 아래 쿼리를 위해 가장 효과적인 튜닝 방안은?

```sql

고객별가입상품 : #고객번호 + #상품ID + *가입일시

> 고객별 가입상품은 평균 10개

SELECT *
  FROM 고객별가입상품
 WHERE 상품ID IN ( 'NH0037', 'NH0041', 'NH0050')
   AND 고객번호 = 1234 

```

정답 : `고객번호 + 상품ID 순으로 구성하고 상품ID를 필터링하는 방식으로 처리`

- 상품ID를 선두에 두면, 상품ID에 대한 IN_List Iterator 방식으로 풀어야 Index Range Scan이 가능하다. 필터 방식으로 처리하면 인덱스를 Full Scan 하게 된다. IN-List Iterator 방식으로 처리하면 인덱스 수직 탐색을 세 번하게 된다.


## 아래 SQL에 대한 튜닝 방안을 인덱스 추가를 통한 튜닝과 SQL 변경을 통한 튜닝 측면에서 각각 작성하시오.

```sql

[인덱스]
PK_거래 인덱스 : 증서번호 + 이체사유발생일자 + 거래코드 + 순번


SELECT NVL((A.기본이체금액 + A.정산이자) - (B.기본이첵므액 + B.정산이자), 0)
  FROM (
    SELECT NVL(SUM(기본이체금액), 0) 기본이체금액
         , NVL(SUM(정산이자), 0) 정산이자
      FROM 거래
     WHERE 증서번호 = :증서번호
       AND 이체사유발생일자 <= :일자
       AND 거래코드 NOT IN ('7411', '7412', '7503' , '7504')
       AND 투입인출구분코드 = 'G'    
  ) A, (
    SELECT NVL(SUM(기본이체금액), 0) 기본이체금액
         , NVL(SUM(정산이자), 0) 정산이자
      FROM 거래
     WHERE 증서번호 = :증서번호
       AND 이체사유발생이자 <= :일자
       AND 거래코드 NOT IN ('7411', '7412', '7503', '7504')
       AND 투입인출구분코드 = 'S'    
  ) B


NESTED LOOPS
  VIEW
    SORT AGGREGATE
      TABLE ACCESS BY INDEX ROWID
        INDEX RANGE SCAN
  VIEW
    SORT AGGREGATE
      TABLE ACCESS BY INDEX ROWID
        INDEX RANGE SCAN      
```

1. 모법답안

증서번호 + 투입인출구분코드 + 이체사유발생일자 (+ 거래코드)  
또는  
투입인출구분코드 + 증서번호 + 이체사유발생일자 (+ 거래코드)

* 거래코드 NOT IN 조건을 만족하는 데이터가 적다면, 거래코드를 인덱스 뒤쪽에 추가하는것이 좋다. 테이블 랜덤 액세스를 그만큼 많이 줄여주기 때문이다. 거래코드 NOT IN 조건을 만족하는 데이터가 대다수라면 굳이 인덱스에 추가하지 않는 것이 좋다. 인덱스 사이즈를 줄이고, DML 성능을 춯게 하기 위해서이다.

2. 모법답안

```sql
SELECT (G_기본이체금액 + G_정산이자) - (S_기본이체금액 + S_정산이자)
  FROM (
    SELECT NVL(SUM(CASE WHEN 투입인출구분코드 = 'G' THEN 기본이체금액 END), 0) G_기본이체금액
         , NVL(SUM(CASE WHEN 투입인출구분코드 = 'G' THEN 정산이자 END), 0) G_정산이자
         , NVL(SUM(CASE WHEN 투입인출구분코드 = 'S' THEN 기본이체금액 END),0) S_기본이체금액
         , NVL(SUM(CASE WHEN 투입인출구분코드 = 'S' THEN 정산이자 END), 0) S_정산이자
      FROM 거래
     WHERE 증서번호 = :증서번호
       AND 이체사유발생일자 <= :일자
       AND 거래코드 NOT IN ('7411', '7412', '7503', '7504')
       AND 투입인출구분코드 IN ('G', 'S')    
  )
```

## 고객ID에 대한 옵션조건을 아래와 같이 LIKE로 처리할 떄의 장단점으로 가장 부적절한것

```sql
SELECT * FROM 거래
WHERE 고객ID :CUST_ID || '%'
  AND 거래일자 BETWEEN :DT1 AND :DT2
```

- 고객ID가 NULL 허용 컬럼일 때 결과집합에 오류가 발생할 수 있다.
- 고객ID 길이가 가변적일 때 결과집합에 오류가 발생할 수 있다.
- 고객ID가 숫자형 컬럼일 때 고객ID가 인덱스 선두 컬럼이면 Index Range Scan이 불가능하고, 거래일자가 선두 컬럼이면 인덱스 스캔 비효율이 발생한다.



## iBatis 프레임워크에서 고객ID에 대한 옵션 조건을 아래와 같이 Dynamic 방식으로 처리하였다. 이를 Static SQL로 구현하고자 할 때 가장 효과적인 방식을 고르시오. (단, 고객ID는 NOT NULL 컬럼)

```sql
<select id="..." paramterClass="..." resultClass="...">

SELECT * FROM 거래
WHERE 거래일자 BETWEEN #DT1# AND #DT2#
  <isNotEmpty prepend="AND" property="cust_id">
    고객ID = #CUST_ID#
  </isNotEmpty>

</select>
```

> SELECT * FROM 거래  
> WHERE 고객ID = NVL(#CUST_ID#, 고객ID)  
> AND 거래일자 BETWEEN #DT1# AND #DT2#

- OR 방식을 사용하면 고객ID가 인덱스 선두 컬럼이어도 Index Range Scan 할 수 없다.
- LIKE 조건으로 구현한 옵션조건에 고객ID가 선두 컬럼인 인덱스를 Range Scan 하는 실행계획이 수립되면, #CUST_ID# 변수에 값을 입력하지 않았을때 인덱스에 모드 거래 테이블을 스캔하는 불상사가 생긴다.
- 옵션조건에 NVL 이나 DECODE 함수를 사용하면 아래와 같은 UNION ALL 형태로 쿼리변환이 작동하므로 고객ID처럼 번별력이 좋은 컬럼에 매우 효과적으로 사용할 수 있다.

```sql
SELECT * FROM 거래
WHERE :CUST_ID IS NULL
AND 거래일자 BETWEEN :DT1 AND :DT2
UNION ALL
SELECT * FROM 거래
WHERE :CUST_ID IS NULL
AND 고객ID = :CUST_ID
AND 거래일자 BETWEEN :DT1 AND :DT2
```

- 옵션조건에 CASE 문을 사용하면 UNION ALL 형태로 쿼리변환이 일어나지 않는다.



# 인덱스 설계

## 다음중 인덱스를 설계할 떄 고려하는 판단 기준은? 

- SQL 수행 빈도
- SQL의 업무상 중요도
- 데이터양과 DML 발생 빈도  : 데이터 양이 많고 DML 발생빈도가 높은 테이블에는 인덱스를 가급적 최소화해야 한다.


## 아래 쿼리를 위한 가장 효과적인 인덱스 구성을 고르시오.

```sql
SELECT 이름, 성별, 전화번호, 부서 
  FROM 사원
 WHERE 성별 = '남자'
   AND 이름 = '홍길동' 
```

> 성별, 이름 두 컬럼 모두 있는 인덱스가 제일 효과적이다.


## 두 SQL을 위해 단 하나의 인덱스를 설계할 떄 가장 효과적인 컬럼은?

```sql

< SQL 1 >
SELECT *
  FROM 거래
 WHERE 상품코드 = :prd_cd
   AND 거래일자 BETWEEN :trd_dt1 AND :trd_dt2;

<SQL 2>
SELECT *
  FROM 거래
 WHERE 상품코드 = :prd_cd
   AND 공급업체코드 LIKE :supl_co_cd || '%'
   AND 거래일자 LIKE :trd_dt1 AND :trd_dt2; 

```

`상품코드 + 거래일자 + 공급업체코드`  

두 SQL에 공통적으로 사용된 조건절은 상품코드와 거래일자다.  
둘 중 '=' 조건인 상품코드를 선두에 두고 BETWEEN 조건인 거래일자를 뒤쪽에 두어야 인덱스 스캔 효율이 좋다.  

만약 거래일자 BETWEEN 조건보다 공급업체코드 LIKE 조건의 선택도가 일반적으로 더 낮으면, SQL 2를 위한 최적 인덱슨느 "상품코드 + 공급업체코드 + 거래일자"다.  
하지만, 인덱스를 이렇게 구성할 경우 SQL 1의 인덱스 스캔 비효율이 매우 안 좋아진다.  
두 SQL 수행빈도가 동일하고 단 하나의 인덱스만 생성해야 한다면, SQL 2의 스캔과정에 약산 비효울이 있더라도 "상품코드 + 거래일자 + 공급업체코드"순으로 구성하는 것이 좋다.


## 아래 SQL을 위해 단 하나의 인덱스를 설계할 때, 가장 안 좋은 컬럼 구성을 고르시오.

```sql
SELECT 고객번호, 고객명, 등록일자, 전화번호, 고객등급
  FROM 고객
 WHERE 등록일자 BETWEEN :DT1 AND :DT2
   AND 등록지점 = '마포'
   AND 성별 = '남자' 


1. 성별 + 등록지점 + 등록일자
2. 등록지점 + 성별 + 등록일자
3. 등록지점 + 등록일자 + 성별
4. 성별 + 등록일자 + 등록지점
```

테이블 랜덤 액세스 횟수는 모두 같다. 따라서 인덱스 스캔 범위에 의해 성능이 결정된다.  
스캔 효율을 위한 최적 인덱스는 "성별 + 등록지점 + 등록일자" 또는 "등록지점 + 성별 + 등록일자"다. 세 컬럼 모두 인덱스 액세스 조건으로 사용되기 떄문이다.

"등록지점 + 등록일자 + 성별" 로 구성하면, 등록지점과 등록일자가 인덱스 액세스 조건이 된다. 따라서 등록지점 =, 등록일자 BETWEEN 조건에 해당하는 구간을 모두 스캔하면서 성별을 필터링한다.  

"성별 + 등록일자 + 등록지점"으로 구성하면, 성별과 등록일자가 인덱스 액세스 조건이 된다.

등록지점보다 성별의 선택도가 더 높으므로 4번의 인덱스 스캔량이 더많다.