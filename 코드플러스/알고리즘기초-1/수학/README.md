# 수학

## 나머지 연산

- 컴퓨터의 정수는 저장할 수 있는 범위가 저장되어 있기 떄문에, 답을 M으로 나눈나머지를 출력하라는 문제가 등장한다.
- (A + B) mod M = ((A mod M) + (B mod M)) mod M
- (A x B) mod M = ((A mod M) X (B mod M)) mod M
- 나누기의 경우에는 설립하지 않는다. ( Modular Inverse를 구해야 함)
- 뺄셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 다음과 같이 해야 한다.
- (A - B) mod M = ((A mod M) - (B mod M) + M) mod M


## 예제 

- (6 -5) % 3 = 1 %  3 = 1 이다.
- (6 % 3 - 5 % 3) % 3 = (0 - 2) % 3 = -2 % 3 = ?

- 음수의 경우 결과의 부호가 프로그래밍 언어마다 다르다.

두번째 결과는 프로그래밍 결과 마다 결과 값이 다름  
Java : -2 가 나온다.


- 0 <= a%c < c,  0 <= b%c < c 이기 때문에 ( a%c - b%c)의 결과는 -c < (a%c - b%c)를 만족한다.
- 따라서, (a%c - b%c +c)는 0보다 큰 값을 갖기 때문에, 이 상태에서 다시 c로 나눠주면 원하는 결과를 얻을 수 있다.

쉽게 말하자면,  (a - b) %c => (a%c - b%c) 로 나타낼 수 있으나, 음수가 되면 프로그래밍 언어마다 다른값이 나와 (a%c - b%c + c) % c 로 변경해서 풀어준다.


## 최대공약수

- 최대공약수는 줄여서 GCD라고 쓴다.
- 두 수 A와 B의 최대공약수 G는 A와 B의 공통된 약수 중에서 가장 큰 정수이다.
- 최대공약수를 구하는 가장 쉬운 방법은 2부터 min(A,B) 까지 모든 정수로 나누어 보는 방법
- 최대공약수가 1인 두 수를 서로소(Comprime)라고 한다.

```java
int g = 1;
for(int i = 2 ; i < Math.min(a, b) ; i++) {
    if (a % i == 0 && b % i == 0) {
        g = i;    
    }    
}
```

###  유클리드 호제법 (Euclidean algorithm)

- 앞 페이지에 있는 방법보다 빠른 방법이 있다. 
- a 를 b로 나눈 나머지를 r이라고 했을 때
- GCD(a,b) = GCD(b,r)과 같다.
- r이 0이면 그 때 b가 최대 공약수 이다.

### 예제 

GCD(24, 16) = GCD(16, 8) = GCD(8,0) = 8

```
r = a % b

GCD(a, b) = GCD(b, r)
```

- 재귀 함수를 사용해서 구현한 유클리드 호제법

```java
int gcd(int a, int b) {
    if (b == 0) {
        return a;    
    } else {
        return gcd(b, a%b);    
    }
}
```

- 재귀함수를 사용하지 않고 구현한 유클리드 호재법

```java
int gcd(int a, int b) {
    while( b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }    
}
```

- 시간복잡도는 log n


## 최소공배수

- 최소공배수는 중여서 LCM이라고 한다.
- 두 수의 최소공배수는 두 수의 공통된 배수 중에서 가장 작은 정수
- 최소공배수는 GCD를 응용해서 구할 수 있다.
- 두 수 a,b 의 최대공약수를 g라고 했을 때
- 최소공배수 l = g * (a/g) * (b/g) 이다.

A X B = 최대공배수 X 최소공배수 이다.

따라서, 최소공배수는 A x B % GCD 이다.


## 소수

- 소수: 약수가 1과 자기 자신 밖에 없는 수
- N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
- 1부터 100까지 소수
- 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...


- 소수와 관련된 알고리즘은 두 가지가 있다.

1. 어떤 수 N이 소수인지 아닌지 판별하는 방법
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

### 어떤 수 N이 소수인지 아닌지 판별하는 방법

- 소수: 약수가 1과 자기 자신 밖에 없는 수
- N이 소수가 되려면, 2보다 크거나 같고, N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
- 1부터 100까지 소수
- 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, ...

```java
boolean prime(int n) {
    if (n < 2) {
        return false;    
    }    
    
    for(int i = 2; i <= n-1; i++) {
        if(n % i == 0) {
            return false;
        }    
    }
    return true;
}
```

- 시간 복잡도 : N

- 더 좋은 방법은? 

N이 소수가 되려면, 2보다 크거나 같고, N/2 보다 작거나 같은 자연수로 나누어 떯어지면 안된다.  
이유: N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 떄문  
N = a x b 로 나타낼 수 있는데, a 가 작을수록 b는 크다.  
가능한 a중에서 가장 작은 값은 2이기 때문에, b는 N/2를 넘지 않는다.

```java
boolean prime(int n) {
    if(n < 2) return false;
    
    for(int i = 2 ; i <= n /2 ; i++) {
        if ( n % i == 0) {
            return false;
        }    
    }
    return true;
}
```

- 시간복잡도 : N/2  이므로 O(N) 입니다.


- 더 좋은 방법은?

N이 소수가 되려면, 2보다 크거나 같고, 루트 N보다 작거나 같은 자연수로 나누어 떨어지면 안된다.  
이유: N이 소수가 아니라면, N = a x b 로 나타낼 수 있다. (a <= b)  
a > b 라면 두 수를 바꿔서 항상 a <= b 로 만들 수 있다.  
두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.  
따라서, 루트 N까지만 검사를 해보면 된다.

```java
boolean prime(int n) {
    if (n < 2) {
        return false;    
    }    
    
    for(int i =2 ; i*i <= n ; i++) {
        if (n % i == 0) {
            return false;
        }    
    }
    return true;
}
```

- 시간 복잡도 : O(루트 N)

## N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법


### 에라토스테네스의 체

- 1부터 N까지 범위 안에 들어가는 모든 소수를 구하려면 에라토스테네스의 체를 사용한다.

1. 2부터 N까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 이제 그 수의 배수를 모두 지운다.

```java
int[] prime = new int[100];  // 소수 저장
int pn = 0; // 소수의 개수 
boolean check = new boolean[101]; // 지워졌으면 true
int n = 100;  // 100까지 소수
for(int i=2 ; i <= n ; i++) {
    if(check[i] == false) {
        prime[pn++] = i;
        for(int j = i*2 ; j <= n ; j += i) {
            check[j] = true;
        }
    }    
}
```

- 1부터 N까지 모든 소수를 구하는 것이 목표이기 때문에, 구현할 떄는 바깥 for문 (i)를 N까지 돌린다.
- 안쪽 for문 (j)는 N의 크기에 따라서, i * i 또는 i * 2 로 바꾸는 것이 좋다.
- i = 백만인 경우 i*i 는 범위를 넘어가기 떄문


### 골드바흐의 추측 ( Goldbach's conjecture )

- 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.
- 위의 문장에 3을 더하면
- 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.
- 로 바뀐다.
- 아직 증명되지 않은 문제
- 10 ^ 18 아하에서는 참인 것이 증명되어 있다.


- 에러스토스테네의 체를 사용한 경우
- 어떤 수 N이 소수인지 아닌지 판별하기 위해 루트 N방법을 사용할 필요가 없다.
- 에라토스테네스의 결과에서 지워지지 않으면 소수, 아니면 소수가 아니기 떄문이다.


## 팩토리얼 ( Factorial )

- N! = 1 X 2 X ... X N
- 팩토리얼은 매우 큰 값
- 6! = 720
- 8! = 40320
- 10! = 3628800


### 팩토리얼 0의 개수

- N! = 1 x 2 x ... x N
- 의 0이 몇 개 인지 알아내는 문제
- 10! = 3628800
- 10!이 0이 2개인 이유는 10!을 소인수분해 해보면 알 수 있다.
- 10! = 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10
- 10! = 1 x 2 x 3 x 2^2 x 5 x 2 x 3 x 7 x 2^3 x 3^2 x 2 x 5
- 10! = 2^8 x 3^4 x 5^2 x 7
- 10! = 2^6 x 3^4 x 7 x (2^2 x 5^2) = x^6 x 3^4 x 7 x 10^2


- N! = 1 x 2 x ... x N
- 의 0이 몇개 인지 알아내려면 N!을 소인수분해 했을 때, 2와 5가 몇 개 나오는지 알아야 한다.
- 5의 개수가 항상 2의 개수 보다 적기 때문에, 5의 개수만 세어주면 된다.
- N! 0의 개수 = [N/5] + [N/5^2] + [N/5^3] + ...


### 조합 0의 개수

- nCm 의 0의 개수