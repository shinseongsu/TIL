# 비트연산자

&, |, ^, ~ 

비트 논리 연산자는 피연산자 정수 값을 비트 단위로 논리 연산을 수행 -> 따라서 결과도 정수 값(int)  
보수 연산자인 ~인 단항 연산자

|       연산자       | 연산자 이름 |        사용         |           의미            |
|:---------------:|:------:|:-----------------:|:-----------------------:|
|        &        | 비트AND  |     op1 & op2     | 비트가 모두 1이면 결과는 1, 아니면 0 |
| &brvbar;  | 비트 OR  | op1  &brvbar; op2 | 비트가 적어도 하나가 1이면 결과는 1, 아니면 0 |
| ^ | 비트 배타적 OR(XOR) | op1 ^ op2 | 비트가 서로 다르면 결과는 1, 같으면 0 |
| ~ | 보수(complement) | ~op1 | 비트가 0이면 결과는 1, 0이면 1 |


| x | y | x & y | x &brvbar; y | ~x |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 |


## ~ 연산자

단항 연산자로 보수 연산자  
각 비트를 0은 1로, 1은 0으로 바꿈

## 음수의 비트 표현

2의 보수표현인 ( 보수 + 1 )  
즉 -1은로 비트로 표현하면 32비트가 모두 1


## 비트 이동 연산자(bit shift operators)
`>> , << , >>>`

| 연산자  | 이름 | 사용 | 연산 방법 | 새로 채워지는 비트 |
|:----:| :---: | :---: | :----: | :----: |
| \>\> | signed left shift | op1 >> op2 | op1을 오른쪽으로 op2 비트만큼 이동 | 가장 왼쪽 비트인 부호 비트는 원래의 비트로 |
|  <<  | signed right shift | op1 << op2 | op1을 왼쪽으로 op2 비트만큼 이동 | 가장 오른쪽 비트를 모두 0으로 채움 |
| >>> | Unsigned right shift | op1 >>> op2 | op1을 오른쪽으로 op2 비트만큼 이동 | 가장 왼쪽 비트인 부호 비트는 모두 0으로 채워짐 |

