# 프로세스와 스레드 기본

## 프로세스

![os](./img/OS.png)

- 프로세스는 운영체제에 연속적으로 실행되고 있는 프로그램을 뜻합니다. 우리(유저)가 프로그램을 실행했다면 프로세스는 메모리 위에 올라가 있게 되며 운영체제게 의해 CPU, 메모리 자원을 할당받게 됩니다.

- 프로세스 독립된 메모리 영역으로 Code, Data, Stack, Heap을 할당받습니다.
  - `Code` 는 개발자가 작성한 코드라고 보시면 됩니다.
  - `Data`는 전역변수, 정적변수, 배열, 구조체 등 프로그램이 실행되면서 생기는 정적인 데이터들이 저장됩니다.
  - `Stack`은 함수 호출과 관련된 정보(실행정보, 지역변수 파라미터 등)이 저장됩니다. 일반적으로 컴파일 타임에 Stack의 크기가 결정됩니다.

> TIP
> Stack Overflow는 프로세스에 할당된 Stack 메모리가 초과되었을 때 생기는 문제입니다.
> 함수에서 너무 큰 지역변수를 선언하거나 재귀적으로 무한정으로 함수를 호출하게 될 떄 발생합니다.

- Heap은 런타임에 동적으로 메모리를 처리해야 하는 상황에서 사용되는 공간입니다.
  - Array을 사용하거나 외부 파일을 읽을 때 등등 예로 들 수 있습니다.
  - 사용자에 의해 메모리 공간이 동적으로 할당되고 해제될 수 있습니다.

## 스레드

![스레드](./img/thread.png)

- 스레드는 특정한 시점에 프로그램의 작업을 수행하는 역활을 합니다. 일반적으로 프로세스 안에서 실제 코드를 실행하는 단위라고 보시면 됩니다.

  - 스레드는 CPU 이용의 기본 단위입니다. 한 개의 스레드 작업은 1개의 CPU코어에 할당되게 됩니다.
  - 스레드가 실행되기 위해선 자원(함수 실행 정보, 지역 변수 등)을 저장할 메모리가 필요하며, 이는 프로세스가 할당받은 메모리를 사용합니다.

- 스레드는 프로세스 내에 존재하기에 프로세스의 자원을 공유하게 됩니다. 각자의 스레드는 Stack을 별도로 가지고 있게 되며 나머지 자원 (Code, Data, Heap)을 공유합니다.

  - 만약 여러 스레드가 실행된다면 프로세스의 자원을 공유하기에 빠르게 자원을 가져다 쓸 수 있습니다. 반면 프로세스가 다른 프로세스의 자원을 사용하기 위해서는 IPC(Inter-Process Communication)이라는 방식을 사용해야 합니다.

- 우리가 개발한 프로그램을 실행하면 일반적으로 1개의 프로세스와 1개의 메인 스레드를 가지게 됩니다. 그러나 프로그램이 해야 할 데스크톱이 많아지면 자연스럽게 여러 개의 스레드를 동시에 실행 할 수 있으며, 혹은 여러개의 프로세스를 동시에 운영할 수도 있습니다.

> TIP
> 프로세스와 스레드의 차이와 장단점을 비교하는 글이 많습니다. 이는 멀티 프로세스, 멀티 스레드를 선택해야 하는 기준에서 나온 장단점일 뿐, 실제로 프로세스와 스레들르 분리해서 비교하는 건 옳지 않습니다.

## 더 공부하면 좋을 것

- 운영체제의 스케줄링 기법

  - 하나의 머신에서 수많은 프로세스들을 효율적으로 관리하기 위해 다양한 스케줄링 기법들이 존재합니다.

- 스레드의 구분 (유저 스레드와 커널 스레드)

  - 실제로 스레드는 유저 스레드와 커널 스레드로 나뉩니다. 이떄 유저 스레드는 운영체제와 자원을 요구하기 위해 커널 스레드와 매핑이 되어 있습니다.

- 다중 스레드 모델
  - 다중 스레드의 경우 유저 스레드와 커널 스레드가 연결되어 있는 방식이 다양합니다.

# 병렬성과 동시성

## 동시성

![동시성](./img/concurrency.png)

## 배경

컴퓨터의의 구성요소 중 하나인 CPU(Central Processing Unit)는 말 그대로 컴퓨터 중심부에서 컴퓨터 명령을 처리하는 역활을 합니다. 우리가 컴퓨터를 사용하여 내리는 명령들, 예를 들어 "크롬 브라우저를 실행해줘"을 바로 이 CPU가 처리하게 됩니다.

컴퓨터가 발전하던 초기에는 컴퓨터 하나당 CPU가 하나였습니다. CPU가 하나이나 한 번에 처리할 수 있는 명령도 하나였습니다. 이런 상황에서 만약 단순한 CPU 계산이 아닌 외부 서버와 통신을 하게 되는 I/O 작업들이 많이 있다면 어떻게 될까요?

예를 들어 어떤 작업이 1분이 걸린다고 하면, 그 중 10초만 CPU를 사용하고 나머지 50초는 API서버의 응답을 기다는 I/O Blocking한 상황입니다. 이 50초 동안 CPU는 아무것도 하지 않고 기다리게 됩니다. (이를 CPU가 블락 상태에 있다고 합니다.)

만약 이 50초 동안 가만히 있는 CPU를 그 다음에 수행되어야 할 작업을 미리 만들어서 넣어준다면, 전체적으로 작업 속도가 더 빨라질 것입니다. 즉 CPU가 가만히 있지 않도곩 최대한 활용하도록 하는 것이죠.

## 개념

이러한 아이디어는 운영체제에서 구현되어, 하나의 CPU를 최대한 활용하여 여러 작업들을 빠르게 수행합니다. 여전히 CPU는 한번에 하나의 명령어만 처리하지만, CPU가 맡는 프로세스(스레드)가 Block 상태가 되면 빠르게 다음에 처리해야할 프로세스가 CPU를 점유하게 됩니다. (CPU 입장에서는 여러 프로세스를 번갈아 가며 일을 하기 위해선 프로세스의 정보들을 메모리에 저장하고 불러와야 합니다. 이떄 CPU가 작업해야할 프로세스를 바꾸는 일을 "컨텍스트 스위치"이라고 합니다.)

CPU가 쉴 틈 없이 한 번에 주어진 데스크톱을 빠르게 처리되다 보니 컴퓨터 사용자는 사실상 모든 프로세스의 명령이 "동시에" 처리된다고 느끼게 됩니다. 이렇게 진행되는 현상을 우리는 `동시성(Concurrency)` 이라고 부릅니다.

> TIP  
> 동시성이라는 개념은 물리적으로 CPU 1개의 코어에서만 동작하는 개념은 아닙니다.  
> 제한된 자원에서 여러 작업을 한번에 실행시키려는 논리적인 개념이라고 보시면 됩니다.

## CPU Bound vs I/O Bound

컴퓨터가 수행하는 하나의 작업은 CPU와 I/O 작업로 이루어집니다.  
이 때 컴퓨터 작업을 크게 2가지로 나눠볼 수 있습니다. 하나의 CPU Bounded Task 이고 다른 하나의 I/O Bound Task 이다.

CPU Bounded Task 작업을 실행하는 데 I/O보다는 CPU를 더 많이 쓰는 작업을 말합니다. 예를 들면 머신 러닝과 같이 연산이 복잡한 로직이 여기에 해당합니다. I/O 작업이 아예없는 것은 아니지만, 대체로 CPU 사용량이 더 압도적입니다.

I/O Bounded Task는 작업을 실행하는데, CPU보다는 I/O 가 더 많은 작업을 말합니다.
예를 들면 크롤링 로직, DB와 연결하여 데이터를 주고받는 로직 등이 여기에 해당합니다. 일반적으로 웹, WAS 서버는 I/O Bounded한 경우가 많습니다.

## 병렬성

![병렬성](./img/parallelism.png)

컴퓨터 하드웨어는 점점 발전하여, 이제 컴퓨터 하나당 2개 이상의 CPU를 가질 수 있게 되었습니다. CPU가 2개 이므로 이제 우리는 동시에 2개의 명령어를 실행할 수 있습니다. 이렇게 여러 개의 작업을 동시에 진행되는 현상을 `병렬성(Parallelism)` 이라고 부릅니다.

위에서 "동시성"은 실제로는 하나의 명령을 빠르게 수행하지만 처리속도가 매우 빨라 여러 작업이 동시에 진행되는 것처럼 "느껴지게" 해주었다면, "실제로" 여러 개의 명령어를 동시에 실행하는 것입니다. 물론 운영체제가 여러 CPU를 골고루 쓰도록 매니징해줍니다.

또한 병렬성은 동싱성을 품을 수도 있습니다. 여러 개의 CPU를 사용하면 각각의 CPU에서 여러 태스크(스레드나 프로세스)를 실행시키려고 한다면 동시성을 구현한 것이죠.

## 정리

- 동시성(Concurrency)은 하나의 CPU로 여러 작업을 빠르게 처리하는 것입니다.

  - 여러 작업이 한번에 실행되는 것처럼 보이지만, 실제로 하나의 CPU에서 처리하고 있는 것입니다.
  - CPU 1코어에 해당하는 물리적인 개념이 아닌, 제한된 자원에서 여러 작업을 한번에 실행시키려는 논리적인 개념입니다.

- 병렬성(Parallelism)은 여러 개의 CPU로 여러 작업을 빠르게 처리하는 것입니다.
  - 여러 작업이 실제로 여러 개의 CPU를 통해 한번에 처리 됩니다.

# 멀티 스레드와 멀티 프로세스

## 멀티 스레딩

보통 우리가 적성하는 코드를 실행하면 하나의 프로세스로 동작합니다. 또, 하나의 프로세스는 보통 하나의 스레드만 사용하여 동작합니다. 예를 들면 파이썬 코드로 이를 확인해볼 수 있습니다.

```python
import os
import threading

def run() -> None:
  print(f"process_id: {os.getpid()}")
  print(f"thread_id: {threading.get_ident()}")

if __name__ == "__main__":
  run()
```

위 코드를 실행하면 다음과 같은 결과가 나옵니다.

```
process_id: 25939
thread_id: 4539137536
```

이렇게 하나의 프로세스에서 하나의 스레드만 사용하는 것을 "싱글 스레딩"이라고 합니다. 우리가 작성하는 대부분의 코드들은 이렇게 싱글 스레딩입니다.

그런데 하나의 프로세스에서 여러 개의 스레드를 사용할 수도 있습니다. 예를 들면 파이썬에서 다음처럼 가능합니다.

```python
import os
import thrading
from concurrent.fufures import ThreadPoolExecutor

def run() -> None:
  print(f"process_id: {os.getpid()}")
  time.sleep(5)    # 5초 동안 대기입니다.
  print(f"thread_id: {threading.get_ident()}")

# run 함수를 실행하는 2개의 스레드를 띄웁니다.
if __name__ == "__main__":
  with ThreadPoolExecutor() as executor:
    n_threads = 2
    for _ in range(n_threads):
      executor.submit(run)
```

위 코드를 실행한 결과는 다음과 같습니다.

```python
process_id: 27188
process_id: 27188    # 같은 프로세스에서 생성했으므로, 프로세스 ID는 같습니다.

# 5초 뒤

thread_id: 123145819027461
thread_id: 498205328902384  # 서로 다른 스레드이므로 스레드 ID는 다릅니다.

```

이렇게 여러 개의 스레드를 사용하는 것을 "멀티 스레딩"이라고 합니다.

![멀티스레딩](./img/multi-threading.png)

멀티 스레딩은 우리가 위에서 배운 "동시성"과 "병렬성"을 구현하는 방법 중 하나입니다.  
컴퓨터가 하나의 CPU 코어만 가진 경우 "동시성" 되고, 여러 개의 코어를 가진 경우 "동시성"과 "병렬성"이 둘 다 구현하는 샘이 됩니다. (여러 개의 CPU코어를 사용하면 동시에, 각 코어에서 여러 개의 스레드를 컨텍스트 스위칭 하며 사용하기도 하기 떄문이죠)

그렇다면 멀티 스레딩은 보통 언제 사용하면 좋을 까요? 멀티 스레딩을 사용하는 대표적인 경우는 독립적인 I/O Bounded 작업이 많은 경우 입니다.

예를 들면 여러 사이트를 크롤링해야 하는 경우, 각 크롤링 작업은 대부분 I/O (해당 서버에 요청하고 응답받기 떄문) 작업이기 떄문에, 멀티 스레딩을 사용하기 좋습니다. 파이썬 코드로 대략적인 코드를 구현하면 다음과 같습니다.

```python
import requests
import concurrent.futures import ThreadPoolExecutor

def parse(html_string: str) -> None:
  # html 문자를 파싱하는 로직이 들어갑니다.
  pass

def crawl(url: str) -> None:
  # 대부분 I/O Bounded 작업입니다.
  res = requests.get(url)
  parse(res.text)

urls = [
  "https://tansfil.tistory.com",
  "https://daliyheumsi.tistory.com",
  "https://zzsza.github.io/",
  "https://www.humphreyahn.dev/"
]

if __name__ == "__main__":
  # 최대 4개의 스레드를 띄워 각 스레드에서 위 주소들을 크롤링합니다.
  # 즉 크롤링(I/O Bounded) 작업이 동시적(concurrency)으로 일어납니다.
  with ThreadPoolExecutor(max_workers=4) as executor:
    for url in range(urls):
      executor.submit(crawl, url)

```

> TIP  
> 파이썬 멀티 스레드는 사실 싱글 스레드처럼 동작합니다.  
> 위에서 멀티 스레딩 코드를 구현했지만, 실제로 파이썬 내부적으로 GIL(Global Interpreter Lock) 이라는 정책에 따라 싱글 스레드 처럼 동작합니다.

# 멀티 프로세싱

지금까지 하나의 프로세스만 사용해왔습니다. 이제 프로그램을 실행에 2개 이상의 프로세스를 사용해봅니다. 이를 멀티 프로세싱이라고 합니다.

예를 들면 파이썬 코드로 다음과 같이 구현할 수 있습니다.

```python
import os
import threading
import time
from concurrent.futures import ProcessPoolExecutor

def run():
  print(f"process_id {os.getpid()}")
  time.sleep(5)
  print(f"thread_id: {thread.get_ident()}")

if __name__ == "__main__":
  with ProcessPoolExecutor() as executor:
    n_processes = 2
      for _ in range(n_processes):
        executor.submit(run)

```

위 코드를 실행하면 다음과 같은 결과가 나옵니다.

```python
process_id: 24953
process_id: 49320  # 서로 프로세스이므로, 프로세스 ID는 다릅니다.

# (5초 뒤 )

thread_id:235720702422
thread_id:102984190241 # 서로 다른 프로세스 내에서 실행되고 있으므로 당연히 스레드 ID도 다릅니다.

```

멀티 프로세싱은 역시 "동시성"과 "병합성"을 구현하는 방법 중 하나입니다. 컴퓨터가 하나의 CPU 코어만 가질 경우 "동시성"이 되고, 여러 개의 코어를 가진 경우 "동시성"과 "병렬성"이 둘 다 구현하는 셈이 됩니다.

그렇다면 언제 멀티 프로세싱을 사용하면 좋을까요? 멀티 프로세싱을 사용하는 대표적인 경우 독립적인 CPU Bounded 작업이 많은 경우입니다.

예를 들면 다음처럼 머신 러닝 코드에서 전처리하는 부분을 멀티 프로세싱을 풀어낼 수 있습니다.

```python
import multiprocessing
from concurrent.futures import ProcessPoolExecutor

import numpy as np

def preprocess(data: np, array) -> np.array:
  # 대부분 CPU Bounded 작업입니다.
  ...

data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
num_cores = multiprocessing.cpu_count()  # 12

if __name__ == "__main__":
  # 데이터를 CPU 코어 수만큼 지웁니다.
  splited_data = np.array_split(data, num_cores)

  # 최대 CPU /코어 개수 만큼의 프로세스를 띄워 각 프로세스에서 데이터를 전처리하는 작업을 합니다.
  # 즉 전처리(CPU Bounded) 작업이 병렬적(parallelism)으로 일어납니다.
  with ProcessPoolExecutor(max_workers=num_cores) as executor:
    for data_chunk in splited_data:
      future = executor.submit(preprocess, data_chunk)
      ...
```

## 멀티 스레드가 멀티 프로세스의 차이

![멀티 스레드와 멀티 프로세스](./img/thread-process.png)

- 멀티 스레드과 멀티 프로세스의 가장 큰 차이는 "메모리를 공유하는가?" 입니다. 멀티 스레드는 여러 개의 스레드가 하나의 프로세스 안에서 같은 메모리를 사용합니다. 반면 ㅁ멀티 프로세스는 각 프로세스가 별도의 메모리 공간을 갖습니다.

- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 사용하며, 스레드간 컨텍스트 스위칭도 빠릅니다. 하지만 같은 메모리에 있는 자원들을 공유하므로, 각 스레드에서 자원 관리에 주의해야 합니다.(동기화 문제) 또한 하나의 스레드가 장애 시 전체 프로세스에 영향을 줍니다.

- 멀티 프로세스는 멀티 스레드보다 더 많은 메모리 공간을 차지하고, 프로세스간 컨텍스트 스위칭도 스레드에 비하면 느린 편입니다. 하지만 각각 독립적인 메모리 공간을 가지기에 자우너 관리를 더 쉽게 할 수 있습니다. 따라서 스레드에 비하면 시스템이 전체적으로 안정적입니다.

- 보통 메모리를 공유해야 하며 간단하게 작업을 구현하고 싶은 경우 멀티 스레딩을 사용하고, 독립적으로 메모리를 가지고 안정적으로 관리하고 싶은 경우 멀티 프로세싱을 사용하는 경우가 많습니다.

## 정리

- 멀티 스레딩은 하나의 프로세스에서 여러 개의 스레드를 사용하는 것입니다.

  - 스레드간 하나의 프레스의 메모리 공간을 공유합니다.
  - 멀티 프로세싱보다 메모리 공간을 적게 쓰고, 컨텍스트 스위칭도 빠릅니다.
  - 하지만 동시성 문제와 안정성에 대한 단점이 있습니다.

- 멀티 프로세싱은 하나의 프로세스에서 여러 프로세스를 사용하는 것입니다.

  - 각 프로세스는 독립된 메모리 공간을 사용합니다.
  - 동시성과 안정성에 대한 장점을 가지지만, 멀티 스레딩보다 메모리 공간을 많이 쓰고, 컨텍스트 스위칭도 느립니다.

- 멀티 스레딩과 멀티 프로세싱은 동시성과 병렬성의 구현 방법입니다.
- 병렬성을 가지면서 동시성을 가질 수도 있습니다.
  - 멀티 프로세싱을 하도록 구현함과 동시에, 각 프로세스에서 멀티 스레딩을 하도록 구현하면 병렬성과 동시성 모두 가져가는 셈입니다.

# 동기와 비동기, 블락과 논블락

## 동기와 비동기

동기(Synchronous)와 비동기(Asyncronus)는 "두 작업의 작동 방식"에 대한 내용입니다.

![동기화-비동기화](./img/syncAndAsync.png)

### 동기(Synchronous)

동기 방식은 작업 A가 작업 B에 작업 요청을 하고 작업 A가 작업 B가 작업을 끝날 때까지 관심을 가지고 기다리는 방식입니다.  
요청을 했을 때 시간이 많이 걸리더라도 요청한 처리에서 결과가 주어셔야 합니다.

예를 들어 우리가 웹 게시판 서버를 운영한다고 합시다. 우리는 어떤 작업에서 서버에 게시글을 생성하라는 요청을 보냈고, 우리는 서버가 게시글을 생서하기까지 기다립니다. 그리고 마침내 서버로부터 게시글 생성 처리가 완료되었다는 메시지를 받았습니다. 우리는 이제 이후에 필요한 작업을 마저 합니다. 이런 작업 방식을 동기적이라고 표현합니다.

우리가 만드는 대부분의 코드는 동기 방식의 코드라고 볼 수 있습니다. 동기 방식은 직관적이고 이해가 쉽습니다. 또한 설계가 비교적 단순합니다.

### 비동기(Asyncronus)

비동기 방식은 작업 A가 작업 B에게 작업 요청을 하고 작업 A가 작업 B가 작업을 끝낼 때까지 관심을 버리고 기다리지 않습니다. 즉, 요청과 결과가 동시에 일어나지 않는 것이죠.

마찬가지로 웹 게시판 서버를 운영한다고 합시다. 서버에 게시글 생성 요청을 보냈는데, 응답으로 요청을 잘 받았고, 처리 중이라는 메시지를 받았습니다. 이제 우리는 필요한 작업을 마처한 뒤, 게시글이 잘 생성되었는지 확인하기 위해 서버에 한번 더 게시글 생성이 완료되었는지 확인하는 요청을 보내야 합니다. 이런 작업 방식을 비동기적이라고 표현합니다.

비동기 방식은 동기보다 비직관적이고 이해하기도 어렵습니다. 또한, 설계도 다소 복잡합니다. 하지만 요청 결과를 받을때까지 기다리지 않고 다른 작업을 수행할 수 있어 효율적입니다.

> WARNING  
> 동기, 비동기는 프로그래밍 언어의 특성이 아닙니다.  
> 예를 들어, 파이썬은 기본적으로 대부분 동기 기반의 코드지만, 내장 지원 라이브러리를 통해 비동기 코드를 작성할 수 있습니다. 반면 자바스크립트는 대표적인 비동기 언어로 소개되곤 하지만, 실제 동기 코드로도 많이 작성합니다.

## 블락과 논블락

블락(Block)과 논블락(NonBlock)은 "작업의 상태"에 대한 내용입니다.

### 블락

일반적으로 함수 A가 함수 B를 호출하면, 프로세스의 제어권은 함수 B로 넘어가게 됩니다. 함수 B가 프로세스의 제어권을 가지고 있는 동안 함수 A는 아무것도 하지 않게 되는데 이 상태를 블락 상태에 있다고 말합니다. 또 이런 함수 B를 블락킹 함수라고 말할 수 있습니다. 함수 B가 모두 실행되고, 프로세스의 제어권이 다시 함수 A로 오게 되면 함수 함수 A의 "블락"상태는 풀리게 되죠

### 논블락

이번에도 마찬가지로 두 함수 A,B가 있다고 합니다. 함수 A에서 함수 B를 스레드로 함수를 호출했습니다. 스레드를 생성하는 함수는 함수 B를 별도의 스레드로 생성하고, 특정 객체를 바로 리턴합니다. 함수 A가 있는 스레드는 함수 호출 이후의 일을 계속해서 하게됩니다. 즉 이과정에서 A는 "블락" 상태를 가지지 않습니다. 이렇게 "블락" 상태를 가지지 않는 상태를 논블락 상태라고 합니다. 또 이런 함수 B를 논블락킹 함수라고 부를 수 있습니다.

블락 / 논블락 접하는 가장 대표적인 사례가 I/O 관련 코드를 작성할 때 입니다.

## 동기/비동기 vs 블락/논블락 차이

![블락/논블락](./img/blockingNonBlocking.png)

동기는 블락과 비동기는 논블락과 비슷한 개념처럼 보입니다.

동기/비동기는 한 작업에서 다른 작업의 작업 완료 여부에 관심이 있느냐에 있습니다.  
즉 관심이 있다면 동기 작업이고, 관심이 없다면 비동기 작업입니다.

한편 블락/논블락은 함 함수에서 호출한 다른 함수가 바로 리턴을 하여, 현재 진행중인 함수 프로세스 제어권을 가져가느냐 아니냐에 있습니다. 호출한 함수가 바로 리턴하지 않아, 프로세스 제어권을 뺏기게 되면 블락상태에 있게 되는 것이다. 반면 바로 리턴하게 된다면 논블락 상태에 있게 되는 것입니다.

> TIP  
> 블락, 논블락 달리 동기, 비동기는 추상적인 개념입니다.  
> 어떤 맥락에서는 블락, 논블락을 동기, 비동기라고 부를 수 있습니다. 따라서 이 개념들을 너무 분리하여 외우실 필요는 없습니다.

## 예시로 이해해보기

좀 더 구체적인 예시를 파이썬 코드와 함꼐 보면 이해해봅시다.

### 동기 / 블락

동기이면서 블락인 상황은 가장 일반적이고, 흔하게 볼 수 있는 상황입니다.

```python
# sync / block

import time

def a():
  print("start in a()")
  time.sleep(3)
  print("finnished in a()")

def b():
  print("start in b()")
  time.sleep(2)
  print("finnished in b()")

def task():
  print("start in task()")
  a()
  b()
  print("finished in task()")

task()
```

코드를 실행하면 다음과 같습니다.

```python
start in task()
start in a()
finished in a()
start in b()
finished in b()
finished in task()
```

task 은 a를 먼저 실행한 후 b를 순차적으로 실행합니다. 두 함수가 실행되는 동안 task 블락 상태에 놓이게 됩니다. 또한 task은 a, b의 작업 완료 여부에 의존적이므로 동기적이라고 볼 수 있습니다.

### 비동기 / 논블락

비동기이면서 논블락인 상황 역시 일반적이고, 흔하게 볼 수 있는 상황입니다.

```python
# async / non-block

import asyncio

async def a():
  print("start in a()")
  await asyncio.sleep(2)
  print("finnished in a()")

async def b():
  print("start in b()")
  await asyncio.sleep(2)
  print("finnished in b()")

async def task():
  print("start in task()")
  asyncio.create_task(a())
  asyncio.creaet_task(b())
  print("finished in task()")
  await asyncio.sleep(3)

async def main():
  await task()

asyncio.run(main())
```

코드를 실행하면 다음과 같습니다.

```python
start in task()
finnished in task()
start in a()
start in b()
finished in a()
finished in b()
```

task는 a와 b를 실행했지만, 두 함수가 실행되고 끝나기까지 기다리지 않습니다. task는 호출 후 논 블락 상태로 본인의 로직을 막힘없이 실행합니다. 또한 task는 a와 b의 작업 종료 여부에 관심이 없으므로 비동기 입니다.

### 동기 / 논블락

자 이제부터가 조금 헷갈립니다. 동기이면서 논블락인 작업은 어떤 결우일까요? 이런 경우를 생각해볼 수 있습니다.

- 작업 A가 작업 B를 실행시키지만, 프로세스 제어권을 놓치지 않는다. -> 논블락
- 작업 A가 어느정도 자신의 작업 이후, 작업 B의 작업 완료 여부에 관심이 있다. -> 동기

흔한 경우는 아닙니다만 이렇게 쓰이는 경우가 종종 있습니다.

```python
# sync/ non-block

import asyncio

global a_task_success
a_task_success = False

async def a():
  print("doing ... in a()")
  await asyncio.sleep(3)
  print("finished a!")
  global a_task_success
  a_task_success = True

async def task():
  print("doing task ...")
  asyncio.create_task(a())

  print(doing somthing ...")
  global a_task_success
  while a_task_sucess is False:
    print("waiting a to be finished ...")
    await asyncio.sleep(1)

asyncio.run(task())
```

코드를 실행하면 다음과 같습니다.

```python
start in task()
doing something ... in task()
start in a()
waiting a() to be finished ... in task()
waiting a() to be finished ... in task()
finished in a()
finished in task()
```

task는 a를 실행하지만 논블락 상태를 가지고 본이의 로직을 막힘없이 실행합니다. 하지만 마지막 while 문에서 a 태스크가 끝나길 기다리고 있습니다. a 태스크가 완료될 떄, a_task_sucess를 True로 바꿔주어야 비로소 task도 끝나게 됩니다. 즉 task는 a의 작업 완료 시점에 의존적이므로 동기적입니다.

### 비동기 / 블락

마찬가지로 헷갈립니다. 비동기인데 블락인 상황은 어떤 경우일까요? 이런 경우를 생각해볼 수 있습니다.

- 작업 A는 작업 B를 실행시켰지만, 작업 A는 작업 B의 작업 완료 여부에 관심이 없습니다. -> 비동기
- 작업 A가 작업 B를 실행시켰지만, 작업 A는 프로세스 제어권을 잃었습니다.

일반적으로 좋은 경우는 아닙니다만, 코드로 구현하면 다음과 같은 모양새입니다.

```python
# sync / non-block

import asyncio

async def a():
  print("start in a()")
  await asyncio.sleep(3)
  print("finished in a()")

async def task():
  print("start in task()")
  value await a()
  print("doing something ... in task()")
  print("finished in task()")

asyncio.run(task())
```

코드를 실행하면 다음과 같습니다.

```python
start in task()
start in a()
finished in a()
doing something ... in task()
finished in task()
```

비동기/블락 결과는 동기/블락과 결과와 같은 확인할 수 있습니다. 보통 비동기 처리 로직에서 데이터베이스의 결과 값을 받아와야만 하는 경우에 이런 방식으로 코드를 작성할 수 있습니다.

## 정리

- 동기와 비동기는 작업 완료에 관심이 있느냐에 관한 작동 방식입니다.

  - 작업 A가 작업 B의 작업 완료에 관심이 있다면 동기입니다.
  - 관심이 없다면 비동기 입니다.

- 블락과 논블락은 프로세스 제어권을 뺏기는 상태에 관한 내용입니다.

  - 함수 A가 함수 B를 호출하고 함수 B가 실행되는 동안 프로세스 제어권을 뺏겨 본인 로직을 실행하지 못하는 경우 블락입니다.
  - 반면 프로세스 제어권을 뺏기지 않고 바로 리턴 받아 본인의 로직을 실행하면 논블락입니다.

- 일반적으로 동기/블락과 비동기/논블락 방식이 쓰입니다.

  - 동기/블락 방식은 이해하기 쉽고 직관적이지만 일반적으로 느립니다.
  - 비동기/논블락 방식은 이해하기 어렵고 프로그램 흐름도 어려워지만 일반적으로 빠릅니다.

- 동기, 비동기, 블락, 논블락의 차이점을 외우려고 하기 보단, 맥락을 파악하는 정도면 충분합니다.
